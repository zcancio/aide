<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>aide</title>
  <!-- Fonts for renderer display components -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;500;600;700&family=Instrument+Sans:wght@400;500;600;700&family=DM+Sans:opsz,wght@9..40,300;9..40,400;9..40,500;9..40,600&display=swap" rel="stylesheet">
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    :root {
      --bg: #0f0f0f;
      --surface: #1a1a1a;
      --border: #2a2a2a;
      --text: #e8e8e8;
      --text-muted: #888;
      --accent: #fff;
      --overlay-bg: rgba(0, 0, 0, 0.3);
      --radius: 12px;
      --input-height: 52px;
      --chat-max-width: 640px;
    }

    html, body {
      height: 100%;
      background: var(--bg);
      color: var(--text);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", system-ui, sans-serif;
      font-size: 14px;
      line-height: 1.5;
      overflow: hidden;
    }

    /* ── DASHBOARD ─────────────────────────────────── */
    #dashboard {
      display: none;
      flex-direction: column;
      height: 100vh;
      overflow-y: auto;
      padding: 40px 24px;
      max-width: 900px;
      margin: 0 auto;
    }

    #dashboard.active { display: flex; }

    .dashboard-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 32px;
    }

    .dashboard-header h1 {
      font-size: 20px;
      font-weight: 600;
      letter-spacing: -0.3px;
    }

    .btn {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 8px 16px;
      border-radius: 8px;
      border: none;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: background 0.15s, opacity 0.15s;
    }

    .btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .btn-primary { background: #7C8C6E; color: #F7F5F2; }
    .btn-primary:hover:not(:disabled) { background: #667358; }
    .btn-ghost { background: transparent; color: var(--text-muted); border: 1px solid var(--border); }
    .btn-ghost:hover { background: var(--surface); color: var(--text); }
    .btn-danger { background: transparent; color: #e55; border: 1px solid #e55; }
    .btn-danger:hover { background: rgba(238,85,85,0.1); }

    .aide-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
      gap: 16px;
    }

    .aide-card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 20px;
      cursor: pointer;
      transition: border-color 0.15s, background 0.15s;
      position: relative;
    }

    .aide-card:hover { border-color: #444; background: #202020; }

    .aide-card-title {
      font-size: 15px;
      font-weight: 500;
      margin-bottom: 8px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      padding-right: 60px;
    }

    .aide-card-meta {
      font-size: 12px;
      color: var(--text-muted);
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .status-badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.4px;
    }

    .status-draft { background: #2a2a2a; color: #888; }
    .status-published { background: rgba(80, 200, 120, 0.15); color: #5c8; }
    .status-archived { background: rgba(255, 100, 100, 0.1); color: #e66; }

    .aide-card-actions {
      position: absolute;
      top: 16px;
      right: 16px;
      display: flex;
      gap: 6px;
      opacity: 0;
      transition: opacity 0.15s;
    }

    .aide-card:hover .aide-card-actions { opacity: 1; }

    .icon-btn {
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      background: var(--border);
      color: var(--text-muted);
      font-size: 13px;
      transition: background 0.15s, color 0.15s;
    }

    .icon-btn:hover { background: #333; color: var(--text); }
    .icon-btn.danger:hover { background: rgba(238,85,85,0.2); color: #e55; }

    .empty-state {
      text-align: center;
      padding: 80px 0;
      color: var(--text-muted);
    }

    .empty-state p { margin-bottom: 20px; font-size: 15px; }

    /* ── EDITOR (preview + chat) ────────────────────── */
    #editor {
      display: none;
      height: 100vh;
      position: relative;
      overflow: hidden;
    }

    #editor.active { display: block; }

    /* Full-viewport inline preview (host element for Shadow DOM) */
    #preview-root {
      width: 100%;
      height: 100%;
      overflow-y: auto;
      background: #fff;
      position: relative;
      padding-bottom: 100px;
    }

    /* Floating chat overlay */
    #chat-overlay {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: min(var(--chat-max-width), calc(100vw - 32px));
      z-index: 100;
      display: flex;
      flex-direction: column;
      gap: 0;
      background: transparent;
      border-radius: var(--radius);
    }

    /* Conversation history (expandable) */
    #history-panel {
      background: rgba(20, 20, 20, 0.9);
      border-radius: var(--radius) var(--radius) 0 0;
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.25s ease, padding 0.25s ease;
    }

    #history-panel.open {
      max-height: 160px;
      overflow-y: auto;
      padding: 12px 16px;
      scrollbar-width: none;
      -ms-overflow-style: none;
    }

    #history-panel::-webkit-scrollbar {
      display: none;
    }

    #history-panel.open + #input-bar {
      border-top: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 0 0 var(--radius) var(--radius);
    }

    .history-message {
      margin-bottom: 8px;
      display: flex;
    }

    .history-message:last-child { margin-bottom: 0; }

    .history-message.user {
      justify-content: flex-end;
    }

    .history-message.assistant {
      justify-content: flex-start;
    }

    .history-content {
      font-size: 13px;
      line-height: 1.5;
      white-space: pre-wrap;
      padding: 8px 12px;
      border-radius: 16px;
      max-width: 85%;
    }

    .history-message.user .history-content {
      background: rgba(60, 60, 60, 0.6);
      color: var(--text);
      border-bottom-right-radius: 4px;
    }

    .history-message.assistant .history-content {
      background: rgba(30, 30, 30, 0.6);
      color: var(--text);
      border-bottom-left-radius: 4px;
    }

    /* Input bar */
    #input-bar {
      background: rgba(20, 20, 20, 0.9);
      border-radius: var(--radius);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* Image preview strip */
    #image-preview-strip {
      display: none;
      padding: 8px 12px 0;
      gap: 8px;
      flex-wrap: wrap;
    }

    #image-preview-strip.has-image { display: flex; }

    .image-thumb {
      position: relative;
      width: 56px;
      height: 56px;
    }

    .image-thumb img {
      width: 56px;
      height: 56px;
      object-fit: cover;
      border-radius: 6px;
      border: 1px solid var(--border);
    }

    .image-thumb-remove {
      position: absolute;
      top: -6px;
      right: -6px;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #333;
      border: 1px solid var(--border);
      color: #fff;
      font-size: 10px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
    }

    /* Row: text + actions */
    .input-row {
      display: flex;
      align-items: flex-end;
      padding: 8px 10px;
      gap: 8px;
      min-height: var(--input-height);
    }

    #message-input {
      flex: 1;
      background: transparent;
      border: none;
      outline: none;
      color: var(--text);
      font-size: 14px;
      font-family: inherit;
      resize: none;
      max-height: 120px;
      overflow-y: auto;
      line-height: 1.5;
      padding: 6px 0;
      scrollbar-width: thin;
    }

    #message-input::placeholder { color: var(--text-muted); }

    .input-actions {
      display: flex;
      align-items: center;
      gap: 4px;
      flex-shrink: 0;
    }

    .action-btn {
      width: 34px;
      height: 34px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 8px;
      border: none;
      cursor: pointer;
      background: transparent;
      color: var(--text-muted);
      font-size: 16px;
      transition: background 0.15s, color 0.15s;
    }

    .action-btn:hover { background: var(--border); color: var(--text); }
    .action-btn:disabled { opacity: 0.4; cursor: not-allowed; }

    #send-btn {
      background: #7C8C6E;         /* sage-500 */
      color: #F7F5F2;              /* warm white */
      border-radius: 8px;
    }

    #send-btn:hover:not(:disabled) { background: #667358; }  /* sage-600 */

    /* Thinking indicator */
    #thinking-indicator {
      display: none;
      align-items: center;
      justify-content: center;
      gap: 6px;
      font-size: 12px;
      color: var(--text-muted);
      padding: 10px 12px;
    }

    #thinking-indicator.visible { display: flex; }

    .thinking-dots {
      display: flex;
      gap: 4px;
    }

    .thinking-dots span {
      width: 6px;
      height: 6px;
      background: var(--text-muted);
      border-radius: 50%;
      animation: thinking-bounce 1.4s infinite ease-in-out both;
    }

    .thinking-dots span:nth-child(1) { animation-delay: -0.32s; }
    .thinking-dots span:nth-child(2) { animation-delay: -0.16s; }
    .thinking-dots span:nth-child(3) { animation-delay: 0s; }

    @keyframes thinking-bounce {
      0%, 80%, 100% { transform: scale(0.6); opacity: 0.4; }
      40% { transform: scale(1); opacity: 1; }
    }

    /* ── FAB (floating action button) ── */
    .fab {
      position: fixed;
      bottom: 24px;
      right: 24px;
      width: 52px;
      height: 52px;
      border-radius: 50%;
      background: #7C8C6E;          /* sage-500 */
      border: none;
      color: #F7F5F2;               /* text-inverse (warm white) */
      font-size: 24px;
      font-weight: 300;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      transition: background 0.15s ease, transform 0.15s ease;
      z-index: 50;
    }

    .fab:hover {
      background: #667358;          /* sage-600 */
      transform: scale(1.05);
    }

    #new-aide-fab {
      display: none;
    }

    #dashboard.active #new-aide-fab {
      display: flex;
    }

    @media (max-width: 767px) {
      .fab {
        bottom: 20px;
        right: 16px;
        width: 48px;
        height: 48px;
        font-size: 22px;
      }
    }

    /* Editor FAB pencil - hidden by default, shown via JS when aide has content */
    #editor-fab {
      display: none;
    }

    #editor-fab.visible {
      display: flex;
    }

    #editor-fab svg {
      width: 24px;
      height: 24px;
    }

    /* Chat overlay collapse state */
    #chat-overlay.collapsed {
      display: none;
    }

    /* ── AUTH ───────────────────────────────────────── */
    #auth-screen {
      display: none;
      align-items: center;
      justify-content: center;
      height: 100vh;
      flex-direction: column;
      gap: 0;
    }

    #auth-screen.active { display: flex; }

    .auth-card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 40px;
      width: 340px;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .auth-title {
      font-size: 18px;
      font-weight: 600;
      letter-spacing: -0.3px;
    }

    .auth-subtitle {
      font-size: 13px;
      color: var(--text-muted);
      margin-top: -12px;
    }

    .auth-form { display: flex; flex-direction: column; gap: 12px; }

    .form-input {
      background: #111;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px 14px;
      color: var(--text);
      font-size: 14px;
      font-family: inherit;
      outline: none;
      width: 100%;
      transition: border-color 0.15s;
    }

    .form-input:focus { border-color: #555; }
    .form-input::placeholder { color: var(--text-muted); }

    .auth-message {
      font-size: 13px;
      color: var(--text-muted);
      text-align: center;
      min-height: 20px;
    }

    .auth-message.error { color: #e66; }
    .auth-message.success { color: #5c8; }

    /* ── MODAL ──────────────────────────────────────── */
    #modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.6);
      backdrop-filter: blur(4px);
      z-index: 300;
      display: none;
      align-items: center;
      justify-content: center;
    }

    #modal-overlay.active { display: flex; }

    .modal {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 28px;
      width: 360px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .modal-title { font-size: 16px; font-weight: 600; }
    .modal-desc { font-size: 13px; color: var(--text-muted); }
    .modal-actions { display: flex; justify-content: flex-end; gap: 10px; margin-top: 4px; }

    /* ── DRAG OVERLAY ───────────────────────────────── */
    #drag-overlay {
      position: fixed;
      inset: 0;
      background: rgba(255,255,255,0.04);
      border: 2px dashed #555;
      border-radius: 12px;
      z-index: 500;
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 15px;
      color: #888;
      pointer-events: none;
    }

    #drag-overlay.active { display: flex; }

    /* Mount animation for progressive entity rendering */
    @keyframes entity-mount {
      from {
        opacity: 0;
        transform: translateY(8px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .entity-new {
      animation: entity-mount 200ms ease-out;
    }

    /* Scrollbar */
    ::-webkit-scrollbar { width: 4px; height: 4px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }
  </style>
  <!-- Display.js: Universal renderer for AIde -->
  <script src="/static/display.js"></script>
</head>
<body>

<!-- Auth screen -->
<div id="auth-screen">
  <div class="auth-card">
    <div>
      <div class="auth-title">aide</div>
      <div class="auth-subtitle">Sign in to continue.</div>
    </div>
    <div id="auth-send-form" class="auth-form">
      <input id="email-input" class="form-input" type="email" placeholder="you@example.com" autocomplete="email" />
      <button id="send-link-btn" class="btn btn-primary" style="width:100%;justify-content:center;">Send magic link</button>
      <p id="auth-msg" class="auth-message"></p>
    </div>
    <div id="auth-sent-msg" style="display:none;text-align:center;">
      <p style="color:var(--text-muted);font-size:13px;">Check your email — link sent.</p>
    </div>
  </div>
</div>

<!-- Dashboard -->
<div id="dashboard">
  <div class="dashboard-header">
    <h1>aide</h1>
  </div>
  <div id="aide-grid" class="aide-grid"></div>
  <div id="empty-state" class="empty-state" style="display:none;">
    <p>Nothing yet.</p>
    <button class="btn btn-ghost" onclick="startNewAide()">Create your first aide</button>
  </div>
  <button id="new-aide-fab" class="fab" onclick="startNewAide()" title="New aide">+</button>
</div>

<!-- Editor -->
<div id="editor">
  <!-- Inline preview div - replaces iframe for real-time React rendering -->
  <div id="preview-root"></div>

  <!-- FAB pencil - shown when aide has content, click to open chat -->
  <button id="editor-fab" class="fab" title="Edit">
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/>
    </svg>
  </button>

  <div id="chat-overlay">
    <div id="history-panel"></div>
    <div id="input-bar">
      <div id="image-preview-strip"></div>
      <div id="thinking-indicator">
        <div class="thinking-dots"><span></span><span></span><span></span></div>
        <span id="thinking-text">Thinking</span>
      </div>
      <div class="input-row">
        <textarea
          id="message-input"
          rows="1"
          placeholder="Tell aide what you're living…"
        ></textarea>
        <div class="input-actions">
          <button id="image-btn" class="action-btn" title="Attach image">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/>
              <polyline points="21 15 16 10 5 21"/>
            </svg>
          </button>
          <input id="image-file-input" type="file" accept="image/jpeg,image/png,image/webp,image/heic" style="display:none;" />
          <button id="stop-btn" class="action-btn" title="Stop" style="display:none;">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
              <rect x="6" y="6" width="12" height="12" rx="2"/>
            </svg>
          </button>
          <button id="send-btn" class="action-btn" title="Send">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
              <path d="M2 21L23 12 2 3v7l15 2-15 2z"/>
            </svg>
          </button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Drag overlay -->
<div id="drag-overlay">Drop image here</div>

<!-- Modal -->
<div id="modal-overlay">
  <div class="modal">
    <div class="modal-title" id="modal-title"></div>
    <div class="modal-desc" id="modal-desc"></div>
    <div id="modal-body"></div>
    <div class="modal-actions" id="modal-actions"></div>
  </div>
</div>

<script>
  // ── State ──────────────────────────────────────────
  let currentUser = null;
  let currentAideId = null;
  let pendingImage = null; // { dataUrl, base64 }
  let conversationHistory = []; // {role, content}
  let isSending = false;
  let pendingPreviewUrl = null; // Server-rendered preview to load when stream ends
  let pendingUserMessage = null; // Track user message for stream persistence
  let pendingVoiceResponse = ''; // Accumulate voice response for stream persistence

  // ── Entity Store ────────────────────────────────────
  // Holds the live entity graph populated by WebSocket deltas.
  const entityStore = {
    entities: {},   // id → entity data
    rootIds: [],    // top-level entity IDs (parent === 'root' or no parent)
    meta: {},       // page metadata (title, description, etc.)

    applyDelta(delta) {
      if (delta.type === 'entity.create') {
        this.entities[delta.id] = delta.data || {};
        const parent = (delta.data || {}).parent;
        if (!parent || parent === 'root') {
          if (!this.rootIds.includes(delta.id)) {
            this.rootIds.push(delta.id);
          }
        }
      } else if (delta.type === 'entity.update') {
        if (this.entities[delta.id]) {
          Object.assign(this.entities[delta.id], delta.data || {});
        } else {
          this.entities[delta.id] = delta.data || {};
        }
      } else if (delta.type === 'entity.remove') {
        delete this.entities[delta.id];
        this.rootIds = this.rootIds.filter(id => id !== delta.id);
      }
      // Update progress indicator with entity count
      updateStreamProgress();
    },

    getChildren(parentId) {
      return Object.entries(this.entities)
        .filter(([, e]) => e.parent === parentId)
        .sort(([, a], [, b]) => (a._created_seq || 0) - (b._created_seq || 0))
        .map(([id]) => id);
    },

    reset() {
      this.entities = {};
      this.rootIds = [];
      this.meta = {};
    },
  };


  // ── Shadow DOM Preview Renderer ────────────────────────────────
  // Uses Shadow DOM for complete CSS isolation between editor and preview

  let shadowRoot = null;

  let activeEditElement = null;

  function startInlineEdit(element) {
    if (activeEditElement) return; // Already editing

    const entityId = element.dataset.entityId;
    const field = element.dataset.field;
    const currentValue = element.textContent;

    activeEditElement = element;
    const originalText = element.textContent;

    // Create input
    const input = document.createElement('input');
    input.type = 'text';
    input.value = currentValue;
    input.className = 'editable-input';
    input.style.cssText = 'font: inherit; color: inherit; background: var(--bg-elevated, #fff); border: 1px solid var(--accent, #7C8C6E); border-radius: var(--radius-sm, 6px); padding: 1px 4px; margin: -2px -5px; outline: none; min-width: 60px; width: 100%;';

    // Replace content with input
    element.textContent = '';
    element.appendChild(input);
    input.focus();
    input.select();

    const finishEdit = (save) => {
      if (activeEditElement !== element) return;
      activeEditElement = null;

      const newValue = input.value;
      element.textContent = save ? newValue : originalText;

      if (save && newValue !== originalText) {
        sendDirectEdit(entityId, field, newValue);
      }
    };

    input.addEventListener('blur', () => finishEdit(true));
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') { e.preventDefault(); input.blur(); }
      if (e.key === 'Escape') { finishEdit(false); }
    });
  }

  // Show/hide chat overlay vs FAB pencil based on content
  function updateChatVisibility() {
    const fab = document.getElementById('editor-fab');
    const chatOverlay = document.getElementById('chat-overlay');
    const hasContent = Object.keys(entityStore.entities).length > 0;

    if (hasContent) {
      // Aide has content: show FAB, hide chat
      fab.classList.add('visible');
      chatOverlay.classList.add('collapsed');
    } else {
      // Empty aide: show chat, hide FAB
      fab.classList.remove('visible');
      chatOverlay.classList.remove('collapsed');
    }
  }

  // Show chat overlay (called when FAB is clicked)
  function showChatOverlay() {
    const fab = document.getElementById('editor-fab');
    const chatOverlay = document.getElementById('chat-overlay');
    fab.classList.remove('visible');
    chatOverlay.classList.remove('collapsed');
    document.getElementById('message-input').focus();
  }

  function refreshEntityPreview() {
    const host = document.getElementById('preview-root');
    if (!host) return;

    // Initialize shadow root on first render
    if (!shadowRoot) {
      shadowRoot = host.attachShadow({ mode: 'open' });

      // Click handler for links, editable fields, and checkboxes
      shadowRoot.addEventListener('click', (e) => {
        // Handle link clicks
        const link = e.target.closest('a');
        if (link && link.href) {
          e.preventDefault();
          window.open(link.href, '_blank');
          return;
        }

        // Handle editable field clicks
        const editable = e.target.closest('.editable-field');
        if (editable && editable.dataset.entityId) {
          e.preventDefault();
          startInlineEdit(editable);
          return;
        }
      });

      // Change handler for checkboxes
      shadowRoot.addEventListener('change', (e) => {
        const checkbox = e.target;
        if (checkbox.type === 'checkbox' && checkbox.dataset.entityId) {
          const entityId = checkbox.dataset.entityId;
          const field = checkbox.dataset.field;
          sendDirectEdit(entityId, field, checkbox.checked);
        }
      });

      // Scroll tracking for sticky section pill
      let rafPending = false;
      let prevPillTitle = null;
      host.addEventListener('scroll', () => {
        if (rafPending) return;
        rafPending = true;
        requestAnimationFrame(() => {
          rafPending = false;
          const NAV_HEIGHT = 44;
          const threshold = NAV_HEIGHT + 10;
          let currentTitle = null;

          // Find all section headers
          const sections = shadowRoot.querySelectorAll('.aide-section');
          for (const section of sections) {
            const rect = section.getBoundingClientRect();
            // Use viewport coordinates since nav bar is fixed to viewport
            if (rect.top < threshold && rect.bottom > threshold + 24) {
              const titleEl = section.querySelector('.aide-section__title');
              if (titleEl) {
                currentTitle = titleEl.textContent.trim();
              }
            }
          }

          // Update pill if title changed
          if (currentTitle !== prevPillTitle) {
            prevPillTitle = currentTitle;
            const pill = shadowRoot.getElementById('sticky-pill');
            if (pill) {
              const pillInner = pill.querySelector('.aide-pill');
              if (currentTitle && pillInner) {
                pill.style.display = 'flex';
                pillInner.textContent = currentTitle;
              } else {
                pill.style.display = 'none';
              }
            }
          }
        });
      }, { passive: true });
    }

    // Save scroll position
    const scrollY = shadowRoot.host.scrollTop;

    // Build HTML from entity store using display.js
    const html = display.renderHtml(entityStore);

    // Render with CSS into shadow DOM
    shadowRoot.innerHTML = `<style>${display.RENDERER_CSS}</style>${html}`;

    // Restore scroll position
    requestAnimationFrame(() => {
      shadowRoot.host.scrollTop = scrollY;
    });
  }

  // ── WebSocket Client ────────────────────────────────
  let aideWs = null;
  let wsConnectedAideId = null;

  function connectWebSocket(aideId) {
    // Close existing connection if switching aides
    if (aideWs && wsConnectedAideId !== aideId) {
      aideWs.close();
      aideWs = null;
    }
    if (aideWs && aideWs.readyState === WebSocket.OPEN) {
      return Promise.resolve();
    }

    const wsId = aideId || 'new';
    const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
    const url = `${proto}//${location.host}/ws/aide/${wsId}`;

    return new Promise((resolve, reject) => {
      try {
        aideWs = new WebSocket(url);
        wsConnectedAideId = wsId;

        aideWs.onopen = () => {
          console.log('[WS] connected:', url);
          resolve();
        };

      let isHydrating = false; // Track if we're receiving initial snapshot

      aideWs.onmessage = (event) => {
        let msg;
        try { msg = JSON.parse(event.data); } catch { return; }

        if (msg.type === 'snapshot.start') {
          // Beginning of initial snapshot hydration - reset store
          isHydrating = true;
          entityStore.reset();
          console.log('[WS] Hydrating snapshot...');
        } else if (msg.type === 'snapshot.end') {
          // End of snapshot hydration - refresh preview once
          isHydrating = false;
          refreshEntityPreview();
          console.log('[WS] Snapshot hydrated:', Object.keys(entityStore.entities).length, 'entities');
          // Show FAB pencil and hide chat if aide has content
          updateChatVisibility();
        } else if (msg.type === 'stream.start') {
          // Don't reset entityStore - keep existing entities for follow-up messages
          // Only reset voice accumulator for new stream
          pendingVoiceResponse = '';
        } else if (msg.type === 'entity.create' || msg.type === 'entity.update' || msg.type === 'entity.remove') {
          entityStore.applyDelta(msg);
          // Only refresh preview during streaming, not during hydration (wait for snapshot.end)
          if (!isHydrating) {
            refreshEntityPreview();
          }
        } else if (msg.type === 'meta.update') {
          // Update page metadata (title, etc.)
          if (msg.data) {
            entityStore.meta = msg.data;
            if (!isHydrating) {
              refreshEntityPreview();
            }
          }
        } else if (msg.type === 'voice') {
          // Show voice text as assistant message in history
          if (msg.text) {
            // Track for persistence (use last voice message as the response)
            pendingVoiceResponse = msg.text;
            // Only add if not already the last assistant message
            const last = conversationHistory[conversationHistory.length - 1];
            if (!last || last.role !== 'assistant' || last.content !== msg.text) {
              conversationHistory.push({ role: 'assistant', content: msg.text });
              renderHistory();
              // Smooth scroll to show new voice message
              const historyPanel = document.getElementById('history-panel');
              if (historyPanel.classList.contains('open')) {
                historyPanel.scrollTo({
                  top: historyPanel.scrollHeight,
                  behavior: 'smooth'
                });
              }
            }
          }
        } else if (msg.type === 'direct_edit.error') {
          console.warn('[WS] direct_edit rejected:', msg.error);
        } else if (msg.type === 'stream.interrupted') {
          console.log('[WS] stream interrupted by user');
          setSendingState(false);
          isSending = false;
        } else if (msg.type === 'stream.end') {
          setSendingState(false);
          isSending = false;
          pendingPreviewUrl = null;

          // Save conversation history only (server saves snapshot in ws.py)
          if (currentAideId && (pendingUserMessage || pendingVoiceResponse)) {
            fetch(`/api/aides/${currentAideId}/conversation`, {
              method: 'POST',
              credentials: 'include',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                message: pendingUserMessage,
                response: pendingVoiceResponse,
              }),
            })
            .then(() => {
              // Clear pending conversation after successful save
              pendingUserMessage = null;
              pendingVoiceResponse = '';
            })
            .catch(err => console.error('Failed to save conversation:', err));
          }
        } else if (msg.type === 'stream.error') {
          const errMsg = msg.error || 'Stream error.';
          conversationHistory.push({ role: 'assistant', content: errMsg });
          renderHistory();
          setSendingState(false);
          isSending = false;
        }
      };

      aideWs.onerror = (err) => {
        console.warn('[WS] error, will fall back to HTTP:', err);
        reject(err);
      };

      aideWs.onclose = () => {
        console.log('[WS] disconnected');
        if (wsConnectedAideId === wsId) {
          aideWs = null;
        }
      };
    } catch (err) {
      console.warn('[WS] could not connect:', err);
      aideWs = null;
      reject(err);
    }
    });
  }

  function sendViaWebSocket(content, messageId) {
    if (!aideWs || aideWs.readyState !== WebSocket.OPEN) return false;
    aideWs.send(JSON.stringify({ type: 'message', content, message_id: messageId }));
    return true;
  }

  function sendDirectEdit(entityId, field, value) {
    if (!aideWs || aideWs.readyState !== WebSocket.OPEN) {
      console.warn('[WS] direct_edit: no open connection');
      return;
    }
    aideWs.send(JSON.stringify({ type: 'direct_edit', entity_id: entityId, field, value }));
  }

  // postMessage listener removed - inline preview calls sendDirectEdit() directly

  // ── Screens ────────────────────────────────────────
  function showScreen(name) {
    document.getElementById('auth-screen').classList.toggle('active', name === 'auth');
    document.getElementById('dashboard').classList.toggle('active', name === 'dashboard');
    document.getElementById('editor').classList.toggle('active', name === 'editor');
  }

  // ── Auth ───────────────────────────────────────────
  async function checkAuth() {
    try {
      const res = await fetch('/auth/me', { credentials: 'include' });
      if (res.ok) {
        currentUser = await res.json();
        // Check if there's an aide ID in the URL
        const aideId = new URLSearchParams(location.search).get('aide');
        console.log('[URL Debug] Page load - URL aide param:', aideId, 'Full URL:', location.href);
        if (aideId) {
          openEditor(aideId);
        } else {
          loadDashboard();
        }
      } else {
        showScreen('auth');
      }
    } catch {
      showScreen('auth');
    }
  }

  document.getElementById('send-link-btn').addEventListener('click', async () => {
    const email = document.getElementById('email-input').value.trim();
    const msg = document.getElementById('auth-msg');
    if (!email) { msg.textContent = 'Enter your email.'; msg.className = 'auth-message error'; return; }

    const btn = document.getElementById('send-link-btn');
    btn.disabled = true;
    msg.textContent = '';

    try {
      const res = await fetch('/auth/send', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email }),
      });
      if (res.ok) {
        document.getElementById('auth-send-form').style.display = 'none';
        document.getElementById('auth-sent-msg').style.display = 'block';
      } else {
        const data = await res.json();
        msg.textContent = data.detail || 'Something went wrong.';
        msg.className = 'auth-message error';
        btn.disabled = false;
      }
    } catch {
      msg.textContent = 'Network error.';
      msg.className = 'auth-message error';
      btn.disabled = false;
    }
  });

  document.getElementById('email-input').addEventListener('keydown', e => {
    if (e.key === 'Enter') document.getElementById('send-link-btn').click();
  });

  // ── Dashboard ──────────────────────────────────────
  async function loadDashboard() {
    showScreen('dashboard');
    const grid = document.getElementById('aide-grid');
    const empty = document.getElementById('empty-state');
    grid.innerHTML = '';

    try {
      const res = await fetch('/api/aides', { credentials: 'include' });
      if (!res.ok) { showScreen('auth'); return; }
      const aides = await res.json();

      if (aides.length === 0) {
        empty.style.display = 'block';
        return;
      }

      empty.style.display = 'none';
      aides.forEach(aide => {
        const card = createAideCard(aide);
        grid.appendChild(card);
      });
    } catch {
      empty.style.display = 'block';
    }
  }

  function createAideCard(aide) {
    const card = document.createElement('div');
    card.className = 'aide-card';

    const updated = new Date(aide.updated_at).toLocaleDateString('en-US', {
      month: 'short', day: 'numeric', year: 'numeric'
    });

    card.innerHTML = `
      <div class="aide-card-title">${escapeHtml(aide.title)}</div>
      <div class="aide-card-meta">
        <span class="status-badge status-${aide.status}">${aide.status}</span>
        <span>${updated}</span>
      </div>
      <div class="aide-card-actions">
        <button class="icon-btn danger" title="Archive" data-id="${aide.id}">×</button>
      </div>
    `;

    card.addEventListener('click', (e) => {
      if (e.target.closest('.aide-card-actions')) return;
      openEditor(aide.id);
    });

    card.querySelector('.icon-btn.danger').addEventListener('click', async (e) => {
      e.stopPropagation();
      const confirmed = await confirmModal('Archive aide?', `"${aide.title}" will be archived.`, 'Archive');
      if (!confirmed) return;
      await archiveAide(aide.id);
    });

    return card;
  }

  async function archiveAide(aideId) {
    await fetch(`/api/aides/${aideId}/archive`, { method: 'POST', credentials: 'include' });
    loadDashboard();
  }

  function startNewAide() {
    openEditor(null);
  }

  // FAB already has onclick="startNewAide()" in HTML — no duplicate listener needed

  // ── Editor ─────────────────────────────────────────
  async function openEditor(aideId) {
    console.log('[URL Debug] openEditor called with aideId:', aideId);
    currentAideId = aideId;
    conversationHistory = [];
    pendingImage = null;

    renderHistory();
    clearImagePreview();
    document.getElementById('message-input').value = '';

    // Always reset entity store when opening editor (new or existing aide)
    // This clears stale data from previous aide before WebSocket hydration
    entityStore.reset();
    refreshEntityPreview();

    // Reset chat visibility - show chat for new aides, let snapshot.end handle existing aides
    const fab = document.getElementById('editor-fab');
    const chatOverlay = document.getElementById('chat-overlay');
    fab.classList.remove('visible');
    chatOverlay.classList.remove('collapsed');

    if (aideId) {
      // Update URL to include aide ID (for refresh persistence)
      history.replaceState({}, '', `?aide=${aideId}`);

      // Load conversation history
      try {
        const res = await fetch(`/api/aides/${aideId}/history`, { credentials: 'include' });
        if (res.ok) {
          const data = await res.json();
          conversationHistory = data.messages || [];
          renderHistory();
        }
      } catch (e) {
        console.error('Failed to load conversation history:', e);
      }
    }

    showScreen('editor');
    document.getElementById('message-input').focus();

    // Connect WebSocket for real-time entity streaming
    // WebSocket will send snapshot.start/snapshot.end to hydrate entityStore
    connectWebSocket(aideId);
  }

  // FAB pencil click - show chat overlay
  document.getElementById('editor-fab').addEventListener('click', showChatOverlay);

  // ── Sending messages ───────────────────────────────
  async function sendMessage() {
    if (isSending) return;
    const input = document.getElementById('message-input');
    const text = input.value.trim();
    if (!text && !pendingImage) return;

    isSending = true;
    setSendingState(true);

    const userContent = text || '(image)';
    conversationHistory.push({ role: 'user', content: userContent });
    renderHistory();

    input.value = '';
    resizeTextarea(input);

    const messageId = 'msg_' + Math.random().toString(36).slice(2, 10);
    clearImagePreview();

    // If new aide, create it first to get aide_id immediately
    if (!currentAideId) {
      try {
        const createRes = await fetch('/api/aides', {
          method: 'POST',
          credentials: 'include',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ title: 'Untitled' }),
        });
        if (createRes.ok) {
          const aideData = await createRes.json();
          currentAideId = aideData.id;
          history.replaceState({}, '', `?aide=${aideData.id}`);
          // Reconnect WebSocket with real aide ID and wait for it
          await connectWebSocket(aideData.id);
        } else if (createRes.status === 401) {
          showScreen('auth');
          return;
        }
      } catch (err) {
        console.error('Failed to create aide:', err);
      }
    }

    // Try WebSocket first (streaming entity deltas)
    const sentViaWs = !pendingImage && sendViaWebSocket(text, messageId);

    if (sentViaWs) {
      // Track user message for persistence at stream.end
      pendingUserMessage = text;
      // WebSocket handles streaming. State persistence happens at stream.end
      // via POST /api/aides/{id}/state (no duplicate LLM call)
      return;
    }

    // Fallback: HTTP-only path (used when no image support in WS or WS unavailable)
    const body = {
      aide_id: currentAideId || undefined,
      message: text || ' ',
      image: pendingImage ? pendingImage.base64 : undefined,
    };

    try {
      const res = await fetch('/api/message', {
        method: 'POST',
        credentials: 'include',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
      });

      if (res.status === 401) { showScreen('auth'); return; }

      const data = await res.json();

      if (!res.ok) {
        conversationHistory.push({ role: 'assistant', content: data.detail || 'Error.' });
        renderHistory();
        return;
      }

      // Update state
      currentAideId = data.aide_id;
      // Update URL for new AIde (persist across refresh)
      history.replaceState({}, '', `?aide=${data.aide_id}`);

      if (data.response_text) {
        conversationHistory.push({ role: 'assistant', content: data.response_text });
        renderHistory();
      }

      // Preview will be refreshed by WebSocket delta events (entity.create/update/remove)
      // No need to manually refresh here - the WebSocket already handles it

    } catch (e) {
      conversationHistory.push({ role: 'assistant', content: 'Network error.' });
      renderHistory();
    } finally {
      isSending = false;
      setSendingState(false);
    }
  }

  // refreshPreview() removed - WebSocket delta events handle all preview updates

  let thinkingInterval = null;
  const thinkingStates = ['Thinking', 'Processing', 'Generating'];

  function updateStreamProgress() {
    // Update progress indicator with entity count during streaming
    if (isSending) {
      const count = Object.keys(entityStore.entities).length;
      const thinkingText = document.getElementById('thinking-text');
      if (count > 0) {
        thinkingText.textContent = `Building (${count} items)`;
      }
    }
  }

  function setSendingState(sending) {
    const sendBtn = document.getElementById('send-btn');
    const stopBtn = document.getElementById('stop-btn');
    const messageInput = document.getElementById('message-input');
    const indicator = document.getElementById('thinking-indicator');
    const thinkingText = document.getElementById('thinking-text');

    // Toggle between send and stop buttons
    sendBtn.style.display = sending ? 'none' : '';
    stopBtn.style.display = sending ? '' : 'none';
    messageInput.disabled = sending;

    if (sending) {
      indicator.classList.add('visible');
      let stateIndex = 0;
      thinkingText.textContent = thinkingStates[0];
      thinkingInterval = setInterval(() => {
        stateIndex = (stateIndex + 1) % thinkingStates.length;
        thinkingText.textContent = thinkingStates[stateIndex];
      }, 2000);
    } else {
      indicator.classList.remove('visible');
      if (thinkingInterval) {
        clearInterval(thinkingInterval);
        thinkingInterval = null;
      }
    }
  }

  // ── History ────────────────────────────────────────
  function renderHistory() {
    const panel = document.getElementById('history-panel');
    if (conversationHistory.length === 0) {
      panel.classList.remove('open');
      panel.innerHTML = '';
      return;
    }

    panel.innerHTML = conversationHistory.map(m => `
      <div class="history-message ${m.role}">
        <div class="history-content">${escapeHtml(m.content)}</div>
      </div>
    `).join('');

    panel.classList.add('open');
    // Delay scroll to allow panel to expand
    setTimeout(() => {
      panel.scrollTop = panel.scrollHeight;
    }, 50);
  }

  // ── Image handling ─────────────────────────────────
  document.getElementById('image-btn').addEventListener('click', () => {
    document.getElementById('image-file-input').click();
  });

  document.getElementById('image-file-input').addEventListener('change', e => {
    const file = e.target.files[0];
    if (file) handleImageFile(file);
    e.target.value = '';
  });

  function handleImageFile(file) {
    if (file.size > 10 * 1024 * 1024) { alert('Image must be under 10 MB.'); return; }
    const reader = new FileReader();
    reader.onload = ev => {
      const dataUrl = ev.target.result;
      const base64 = dataUrl.split(',')[1];
      pendingImage = { dataUrl, base64 };
      showImagePreview(dataUrl);
    };
    reader.readAsDataURL(file);
  }

  function showImagePreview(dataUrl) {
    const strip = document.getElementById('image-preview-strip');
    strip.innerHTML = `
      <div class="image-thumb">
        <img src="${dataUrl}" alt="attachment" />
        <button class="image-thumb-remove" id="remove-image-btn">×</button>
      </div>
    `;
    strip.classList.add('has-image');
    document.getElementById('remove-image-btn').addEventListener('click', clearImagePreview);
  }

  function clearImagePreview() {
    pendingImage = null;
    const strip = document.getElementById('image-preview-strip');
    strip.innerHTML = '';
    strip.classList.remove('has-image');
  }

  // Drag-and-drop
  let dragCounter = 0;
  document.addEventListener('dragenter', e => {
    if (e.dataTransfer.types.includes('Files')) {
      dragCounter++;
      document.getElementById('drag-overlay').classList.add('active');
    }
  });
  document.addEventListener('dragleave', () => {
    dragCounter--;
    if (dragCounter <= 0) {
      dragCounter = 0;
      document.getElementById('drag-overlay').classList.remove('active');
    }
  });
  document.addEventListener('dragover', e => e.preventDefault());
  document.addEventListener('drop', e => {
    e.preventDefault();
    dragCounter = 0;
    document.getElementById('drag-overlay').classList.remove('active');
    const file = e.dataTransfer.files[0];
    if (file && file.type.startsWith('image/')) handleImageFile(file);
  });

  // ── Input handlers ─────────────────────────────────
  const messageInput = document.getElementById('message-input');

  messageInput.addEventListener('input', () => resizeTextarea(messageInput));

  messageInput.addEventListener('keydown', e => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendMessage();
    }
  });

  document.getElementById('send-btn').addEventListener('click', sendMessage);

  // Stop button handler - interrupts the current stream
  document.getElementById('stop-btn').addEventListener('click', () => {
    if (aideWs && aideWs.readyState === WebSocket.OPEN) {
      aideWs.send(JSON.stringify({ type: 'interrupt' }));
    }
  });

  function resizeTextarea(el) {
    el.style.height = 'auto';
    el.style.height = Math.min(el.scrollHeight, 120) + 'px';
  }

  // ── Modals ─────────────────────────────────────────
  function openModal({ title, desc, body = '', actions }) {
    document.getElementById('modal-title').textContent = title;
    document.getElementById('modal-desc').textContent = desc;
    document.getElementById('modal-body').innerHTML = body;
    document.getElementById('modal-actions').innerHTML = actions;
    document.getElementById('modal-overlay').classList.add('active');
  }

  function closeModal() {
    document.getElementById('modal-overlay').classList.remove('active');
  }

  function confirmModal(title, desc, confirmLabel = 'Confirm') {
    return new Promise(resolve => {
      openModal({
        title, desc,
        actions: `
          <button class="btn btn-ghost" id="modal-cancel">Cancel</button>
          <button class="btn btn-danger" id="modal-confirm">${escapeHtml(confirmLabel)}</button>
        `,
      });
      document.getElementById('modal-cancel').onclick = () => { closeModal(); resolve(false); };
      document.getElementById('modal-confirm').onclick = () => { closeModal(); resolve(true); };
    });
  }

  function promptModal(title, desc, placeholder = '') {
    return new Promise(resolve => {
      openModal({
        title, desc,
        body: `<input id="modal-input" class="form-input" placeholder="${escapeHtml(placeholder)}" style="margin-top:4px;" />`,
        actions: `
          <button class="btn btn-ghost" id="modal-cancel">Cancel</button>
          <button class="btn btn-primary" id="modal-confirm">OK</button>
        `,
      });
      const inp = document.getElementById('modal-input');
      inp.focus();
      const submit = () => { const v = inp.value.trim(); closeModal(); resolve(v || null); };
      inp.addEventListener('keydown', e => { if (e.key === 'Enter') submit(); });
      document.getElementById('modal-cancel').onclick = () => { closeModal(); resolve(null); };
      document.getElementById('modal-confirm').onclick = submit;
    });
  }

  function alertModal(title, desc) {
    return new Promise(resolve => {
      openModal({
        title, desc,
        actions: `<button class="btn btn-primary" id="modal-ok">OK</button>`,
      });
      document.getElementById('modal-ok').onclick = () => { closeModal(); resolve(); };
    });
  }

  document.getElementById('modal-overlay').addEventListener('click', e => {
    if (e.target === document.getElementById('modal-overlay')) closeModal();
  });

  // ── Utils ──────────────────────────────────────────
  function escapeHtml(s) {
    return String(s)
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;');
  }

  // Handle magic link token in URL
  const urlParams = new URLSearchParams(location.search);
  const token = urlParams.get('token');
  if (token) {
    fetch(`/auth/verify?token=${encodeURIComponent(token)}`, { credentials: 'include' })
      .then(res => {
        history.replaceState({}, '', '/');
        if (res.ok) return res.json().then(user => { currentUser = user; loadDashboard(); });
        showScreen('auth');
      })
      .catch(() => showScreen('auth'));
  } else {
    checkAuth();
  }
</script>
</body>
</html>
