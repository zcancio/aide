<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AIde</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    :root {
      --bg: #0f0f0f;
      --surface: #1a1a1a;
      --border: #2a2a2a;
      --text: #e8e8e8;
      --text-muted: #888;
      --accent: #fff;
      --overlay-bg: rgba(0, 0, 0, 0.3);
      --radius: 12px;
      --input-height: 52px;
      --chat-max-width: 640px;
    }

    html, body {
      height: 100%;
      background: var(--bg);
      color: var(--text);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", system-ui, sans-serif;
      font-size: 14px;
      line-height: 1.5;
      overflow: hidden;
    }

    /* ── DASHBOARD ─────────────────────────────────── */
    #dashboard {
      display: none;
      flex-direction: column;
      height: 100vh;
      overflow-y: auto;
      padding: 40px 24px;
      max-width: 900px;
      margin: 0 auto;
    }

    #dashboard.active { display: flex; }

    .dashboard-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 32px;
    }

    .dashboard-header h1 {
      font-size: 20px;
      font-weight: 600;
      letter-spacing: -0.3px;
    }

    .btn {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 8px 16px;
      border-radius: 8px;
      border: none;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: background 0.15s, opacity 0.15s;
    }

    .btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .btn-primary { background: var(--accent); color: #000; }
    .btn-primary:hover:not(:disabled) { background: #ddd; }
    .btn-ghost { background: transparent; color: var(--text-muted); border: 1px solid var(--border); }
    .btn-ghost:hover { background: var(--surface); color: var(--text); }
    .btn-danger { background: transparent; color: #e55; border: 1px solid #e55; }
    .btn-danger:hover { background: rgba(238,85,85,0.1); }

    .aide-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
      gap: 16px;
    }

    .aide-card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 20px;
      cursor: pointer;
      transition: border-color 0.15s, background 0.15s;
      position: relative;
    }

    .aide-card:hover { border-color: #444; background: #202020; }

    .aide-card-title {
      font-size: 15px;
      font-weight: 500;
      margin-bottom: 8px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      padding-right: 60px;
    }

    .aide-card-meta {
      font-size: 12px;
      color: var(--text-muted);
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .status-badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.4px;
    }

    .status-draft { background: #2a2a2a; color: #888; }
    .status-published { background: rgba(80, 200, 120, 0.15); color: #5c8; }
    .status-archived { background: rgba(255, 100, 100, 0.1); color: #e66; }

    .aide-card-actions {
      position: absolute;
      top: 16px;
      right: 16px;
      display: flex;
      gap: 6px;
      opacity: 0;
      transition: opacity 0.15s;
    }

    .aide-card:hover .aide-card-actions { opacity: 1; }

    .icon-btn {
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      background: var(--border);
      color: var(--text-muted);
      font-size: 13px;
      transition: background 0.15s, color 0.15s;
    }

    .icon-btn:hover { background: #333; color: var(--text); }
    .icon-btn.danger:hover { background: rgba(238,85,85,0.2); color: #e55; }

    .empty-state {
      text-align: center;
      padding: 80px 0;
      color: var(--text-muted);
    }

    .empty-state p { margin-bottom: 20px; font-size: 15px; }

    /* ── EDITOR (preview + chat) ────────────────────── */
    #editor {
      display: none;
      height: 100vh;
      position: relative;
    }

    #editor.active { display: block; }

    /* Full-viewport preview iframe */
    #preview-frame {
      width: 100%;
      height: 100%;
      border: none;
      background: #fff;
    }

    /* Floating chat overlay */
    #chat-overlay {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: min(var(--chat-max-width), calc(100vw - 32px));
      z-index: 100;
      display: flex;
      flex-direction: column;
      gap: 0;
      background: transparent;
      border-radius: var(--radius);
    }

    /* Conversation history (expandable) */
    #history-panel {
      background: rgba(20, 20, 20, 0.9);
      border-radius: var(--radius) var(--radius) 0 0;
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.25s ease, padding 0.25s ease;
    }

    #history-panel.open {
      max-height: 160px;
      overflow-y: auto;
      padding: 12px 16px;
      scrollbar-width: none;
      -ms-overflow-style: none;
    }

    #history-panel::-webkit-scrollbar {
      display: none;
    }

    #history-panel.open + #input-bar {
      border-top: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 0 0 var(--radius) var(--radius);
    }

    .history-message {
      margin-bottom: 8px;
      display: flex;
    }

    .history-message:last-child { margin-bottom: 0; }

    .history-message.user {
      justify-content: flex-end;
    }

    .history-message.assistant {
      justify-content: flex-start;
    }

    .history-content {
      font-size: 13px;
      line-height: 1.5;
      white-space: pre-wrap;
      padding: 8px 12px;
      border-radius: 16px;
      max-width: 85%;
    }

    .history-message.user .history-content {
      background: rgba(60, 60, 60, 0.6);
      color: var(--text);
      border-bottom-right-radius: 4px;
    }

    .history-message.assistant .history-content {
      background: rgba(30, 30, 30, 0.6);
      color: var(--text);
      border-bottom-left-radius: 4px;
    }

    /* Input bar */
    #input-bar {
      background: rgba(20, 20, 20, 0.9);
      border-radius: var(--radius);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* Image preview strip */
    #image-preview-strip {
      display: none;
      padding: 8px 12px 0;
      gap: 8px;
      flex-wrap: wrap;
    }

    #image-preview-strip.has-image { display: flex; }

    .image-thumb {
      position: relative;
      width: 56px;
      height: 56px;
    }

    .image-thumb img {
      width: 56px;
      height: 56px;
      object-fit: cover;
      border-radius: 6px;
      border: 1px solid var(--border);
    }

    .image-thumb-remove {
      position: absolute;
      top: -6px;
      right: -6px;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #333;
      border: 1px solid var(--border);
      color: #fff;
      font-size: 10px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
    }

    /* Row: text + actions */
    .input-row {
      display: flex;
      align-items: flex-end;
      padding: 8px 10px;
      gap: 8px;
      min-height: var(--input-height);
    }

    #message-input {
      flex: 1;
      background: transparent;
      border: none;
      outline: none;
      color: var(--text);
      font-size: 14px;
      font-family: inherit;
      resize: none;
      max-height: 120px;
      overflow-y: auto;
      line-height: 1.5;
      padding: 6px 0;
      scrollbar-width: thin;
    }

    #message-input::placeholder { color: var(--text-muted); }

    .input-actions {
      display: flex;
      align-items: center;
      gap: 4px;
      flex-shrink: 0;
    }

    .action-btn {
      width: 34px;
      height: 34px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 8px;
      border: none;
      cursor: pointer;
      background: transparent;
      color: var(--text-muted);
      font-size: 16px;
      transition: background 0.15s, color 0.15s;
    }

    .action-btn:hover { background: var(--border); color: var(--text); }
    .action-btn:disabled { opacity: 0.4; cursor: not-allowed; }

    #send-btn {
      background: var(--accent);
      color: #000;
      border-radius: 8px;
    }

    #send-btn:hover:not(:disabled) { background: #ddd; }

    /* Thinking indicator */
    #thinking-indicator {
      display: none;
      align-items: center;
      justify-content: center;
      gap: 6px;
      font-size: 12px;
      color: var(--text-muted);
      padding: 10px 12px;
    }

    #thinking-indicator.visible { display: flex; }

    .thinking-dots {
      display: flex;
      gap: 4px;
    }

    .thinking-dots span {
      width: 6px;
      height: 6px;
      background: var(--text-muted);
      border-radius: 50%;
      animation: thinking-bounce 1.4s infinite ease-in-out both;
    }

    .thinking-dots span:nth-child(1) { animation-delay: -0.32s; }
    .thinking-dots span:nth-child(2) { animation-delay: -0.16s; }
    .thinking-dots span:nth-child(3) { animation-delay: 0s; }

    @keyframes thinking-bounce {
      0%, 80%, 100% { transform: scale(0.6); opacity: 0.4; }
      40% { transform: scale(1); opacity: 1; }
    }

    /* Back button (editor toolbar) */
    #editor-back {
      position: fixed;
      top: 14px;
      left: 14px;
      z-index: 200;
      background: rgba(20, 20, 20, 0.9);
      border: none;
      border-radius: var(--radius);
      width: 36px;
      height: 36px;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 0;
      color: var(--text);
      cursor: pointer;
      font-size: 16px;
      transition: background 0.15s;
    }

    #editor-back.visible { display: flex; }
    #editor-back:hover { background: rgba(30, 30, 30, 0.95); }

    /* Publish button (editor toolbar) */
    #publish-btn-floating {
      position: fixed;
      top: 14px;
      right: 14px;
      z-index: 200;
      background: rgba(20, 20, 20, 0.9);
      border: none;
      border-radius: var(--radius);
      padding: 8px 16px;
      color: var(--text);
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      display: none;
      align-items: center;
      transition: background 0.15s;
    }

    #publish-btn-floating.visible { display: flex; }
    #publish-btn-floating:hover { background: rgba(30, 30, 30, 0.95); }

    /* ── AUTH ───────────────────────────────────────── */
    #auth-screen {
      display: none;
      align-items: center;
      justify-content: center;
      height: 100vh;
      flex-direction: column;
      gap: 0;
    }

    #auth-screen.active { display: flex; }

    .auth-card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 40px;
      width: 340px;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .auth-title {
      font-size: 18px;
      font-weight: 600;
      letter-spacing: -0.3px;
    }

    .auth-subtitle {
      font-size: 13px;
      color: var(--text-muted);
      margin-top: -12px;
    }

    .auth-form { display: flex; flex-direction: column; gap: 12px; }

    .form-input {
      background: #111;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px 14px;
      color: var(--text);
      font-size: 14px;
      font-family: inherit;
      outline: none;
      width: 100%;
      transition: border-color 0.15s;
    }

    .form-input:focus { border-color: #555; }
    .form-input::placeholder { color: var(--text-muted); }

    .auth-message {
      font-size: 13px;
      color: var(--text-muted);
      text-align: center;
      min-height: 20px;
    }

    .auth-message.error { color: #e66; }
    .auth-message.success { color: #5c8; }

    /* ── MODAL ──────────────────────────────────────── */
    #modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.6);
      backdrop-filter: blur(4px);
      z-index: 300;
      display: none;
      align-items: center;
      justify-content: center;
    }

    #modal-overlay.active { display: flex; }

    .modal {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 28px;
      width: 360px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .modal-title { font-size: 16px; font-weight: 600; }
    .modal-desc { font-size: 13px; color: var(--text-muted); }
    .modal-actions { display: flex; justify-content: flex-end; gap: 10px; margin-top: 4px; }

    /* ── DRAG OVERLAY ───────────────────────────────── */
    #drag-overlay {
      position: fixed;
      inset: 0;
      background: rgba(255,255,255,0.04);
      border: 2px dashed #555;
      border-radius: 12px;
      z-index: 500;
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 15px;
      color: #888;
      pointer-events: none;
    }

    #drag-overlay.active { display: flex; }

    /* Mount animation for progressive entity rendering */
    @keyframes entity-mount {
      from {
        opacity: 0;
        transform: translateY(8px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .entity-new {
      animation: entity-mount 200ms ease-out;
    }

    /* Scrollbar */
    ::-webkit-scrollbar { width: 4px; height: 4px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }
  </style>
  <!-- CSS from renderer.py (source of truth for styling) -->
  <script id="renderer-css-template" type="text/template">
/* CSS custom properties - exact copy from renderer.py */
:root {
  /* Design system defaults */
  --font-serif: 'Cormorant Garamond', Georgia, serif;
  --font-sans: 'IBM Plex Sans', -apple-system, sans-serif;
  --text-primary: #1a1a1a;
  --text-secondary: #4a4a4a;
  --text-tertiary: #8a8a8a;
  --text-slate: #374151;
  --bg-primary: #fafaf9;
  --bg-cream: #f5f1eb;
  --accent-navy: #1f2a44;
  --accent-steel: #5a6e8a;
  --accent-forest: #2d5a3d;
  --border: #d4d0c8;
  --border-light: #e8e4dc;
  --radius-sm: 4px;
  --radius-md: 8px;
  /* Spacing scale */
  --space-0: 0px;
  --space-1: 4px;
  --space-2: 8px;
  --space-3: 12px;
  --space-4: 16px;
  --space-5: 20px;
  --space-6: 24px;
  --space-7: 32px;
  --space-8: 40px;
  --space-9: 48px;
  --space-10: 56px;
  --space-11: 64px;
  --space-12: 80px;
  --space-13: 96px;
  --space-14: 112px;
  --space-15: 128px;
  --space-16: 160px;
}

/* ── Base ── */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

body {
  font-family: var(--font-sans);
  font-size: 16px;
  font-weight: 300;
  line-height: 1.65;
  color: var(--text-primary);
  background: var(--bg-primary);
  -webkit-font-smoothing: antialiased;
}

.aide-page {
  max-width: 720px;
  margin: 0 auto;
  padding: var(--space-12) var(--space-8);
}

@media (max-width: 640px) {
  .aide-page {
    padding: var(--space-8) var(--space-5);
  }
}

@media (prefers-reduced-motion: reduce) {
  *, *::before, *::after {
    animation-duration: 0.01ms !important;
    transition-duration: 0.01ms !important;
  }
}

/* ── Headings ── */
.aide-heading { margin-bottom: var(--space-4); }
.aide-heading--1 {
  font-family: var(--font-serif);
  font-size: clamp(32px, 4.5vw, 42px);
  font-weight: 400;
  line-height: 1.2;
  color: var(--text-primary);
}
.aide-heading--2 {
  font-family: var(--font-serif);
  font-size: clamp(24px, 3.5vw, 32px);
  font-weight: 400;
  line-height: 1.25;
  color: var(--text-primary);
}
.aide-heading--3 {
  font-family: var(--font-sans);
  font-size: 18px;
  font-weight: 500;
  line-height: 1.4;
  color: var(--text-primary);
}

/* ── Text ── */
.aide-text {
  font-family: var(--font-sans);
  font-size: 16px;
  font-weight: 300;
  line-height: 1.65;
  color: var(--text-secondary);
  margin-bottom: var(--space-4);
}
.aide-text a {
  color: var(--accent-steel);
  text-decoration: underline;
  text-decoration-color: var(--border);
  text-underline-offset: 2px;
}
.aide-text a:hover {
  text-decoration-color: var(--accent-steel);
}

/* ── Metric ── */
.aide-metric {
  display: flex;
  align-items: baseline;
  gap: var(--space-2);
  padding: var(--space-3) 0;
}
.aide-metric__label {
  font-family: var(--font-sans);
  font-size: 15px;
  font-weight: 400;
  color: var(--text-secondary);
}
.aide-metric__label::after { content: ':'; }
.aide-metric__value {
  font-family: var(--font-sans);
  font-size: 15px;
  font-weight: 500;
  color: var(--text-primary);
}

/* ── Divider ── */
.aide-divider {
  border: none;
  border-top: 1px solid var(--border-light);
  margin: var(--space-6) 0;
}

/* ── Image ── */
.aide-image { margin: var(--space-6) 0; }
.aide-image img { max-width: 100%; height: auto; border-radius: var(--radius-sm); }
.aide-image__caption {
  font-size: 13px;
  color: var(--text-tertiary);
  margin-top: var(--space-2);
}

/* ── Callout ── */
.aide-callout {
  background: var(--bg-cream);
  border-left: 3px solid var(--border);
  padding: var(--space-4) var(--space-5);
  margin: var(--space-4) 0;
  border-radius: 0 var(--radius-sm) var(--radius-sm) 0;
  font-size: 15px;
  line-height: 1.55;
  color: var(--text-slate);
}

/* ── Columns ── */
.aide-columns {
  display: flex;
  gap: var(--space-6);
}
@media (max-width: 640px) {
  .aide-columns {
    flex-direction: column;
  }
}

/* ── Empty states ── */
.aide-empty {
  color: var(--text-tertiary);
  font-size: 15px;
  padding: var(--space-16) 0;
  text-align: center;
}
.aide-collection-empty {
  color: var(--text-tertiary);
  font-size: 14px;
  padding: var(--space-4) 0;
}

/* ── Highlight ── */
.aide-highlight {
  background-color: rgba(31, 42, 68, 0.04);
}

/* ── List view ── */
.aide-list {
  list-style: none;
  padding: 0;
}
.aide-list__item {
  display: flex;
  align-items: baseline;
  gap: var(--space-3);
  padding: var(--space-3) 0;
  border-bottom: 1px solid var(--border-light);
  font-size: 15px;
  line-height: 1.5;
}
.aide-list__item:last-child { border-bottom: none; }
.aide-list__field--primary {
  font-weight: 500;
  color: var(--text-primary);
}
.aide-list__field {
  color: var(--text-secondary);
}

/* ── Table view ── */
.aide-table-wrap {
  overflow-x: auto;
  margin: var(--space-4) 0;
}
.aide-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 15px;
}
.aide-table__th {
  font-family: var(--font-sans);
  font-size: 11px;
  font-weight: 500;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  color: var(--text-tertiary);
  text-align: left;
  padding: var(--space-2) var(--space-3);
  border-bottom: 2px solid var(--border);
}
.aide-table__td {
  padding: var(--space-3);
  border-bottom: 1px solid var(--border-light);
  color: var(--text-slate);
  vertical-align: top;
}
.aide-table__td--bool { text-align: center; }
.aide-table__td--int,
.aide-table__td--float { text-align: right; font-variant-numeric: tabular-nums; }

/* ── Grid view ── */
.aide-grid {
  border-collapse: collapse;
  font-size: 13px;
}
.aide-grid__col-label,
.aide-grid__row-label {
  font-weight: 500;
  color: var(--text-tertiary);
  padding: var(--space-2);
  text-align: center;
}
.aide-grid__cell {
  border: 1px solid var(--border-light);
  padding: var(--space-2);
  text-align: center;
  min-width: 48px;
  min-height: 48px;
  vertical-align: middle;
}
.aide-grid__cell--filled {
  background: var(--bg-cream);
  color: var(--text-primary);
  font-weight: 500;
}
.aide-grid__cell--empty {
  color: var(--text-tertiary);
}

/* ── Group headers ── */
.aide-group { margin-bottom: var(--space-6); }
.aide-group__header {
  font-family: var(--font-sans);
  font-size: 11px;
  font-weight: 500;
  letter-spacing: 0.1em;
  text-transform: uppercase;
  color: var(--text-tertiary);
  margin-bottom: var(--space-3);
  padding-bottom: var(--space-2);
  border-bottom: 1px solid var(--border-light);
}

/* ── Annotations ── */
.aide-annotations { margin-top: var(--space-10); }
.aide-annotation {
  padding: var(--space-3) 0;
  border-bottom: 1px solid var(--border-light);
}
.aide-annotation:last-child { border-bottom: none; }
.aide-annotation__text {
  font-size: 15px;
  color: var(--text-slate);
  line-height: 1.5;
}
.aide-annotation__meta {
  font-size: 12px;
  color: var(--text-tertiary);
  margin-left: var(--space-3);
}
.aide-annotation--pinned {
  border-left: 3px solid var(--accent-navy);
  padding-left: var(--space-4);
}

/* ── Footer ── */
.aide-footer {
  margin-top: var(--space-16);
  padding-top: var(--space-6);
  border-top: 1px solid var(--border-light);
  font-size: 12px;
  color: var(--text-tertiary);
  text-align: center;
}
.aide-footer__link {
  color: var(--text-tertiary);
  text-decoration: none;
}
.aide-footer__link:hover {
  color: var(--text-secondary);
}

/* ── Card (React component) ── */
.aide-card {
  background: #fff;
  border: 1px solid var(--border-light);
  border-radius: var(--radius-md);
  padding: var(--space-4);
  margin-bottom: var(--space-3);
}
.aide-card__title {
  font-size: 15px;
  font-weight: 500;
  color: var(--text-primary);
  margin-bottom: var(--space-2);
}
.aide-card__field {
  display: flex;
  justify-content: space-between;
  align-items: baseline;
  padding: var(--space-1) 0;
  border-bottom: 1px solid var(--border-light);
  gap: var(--space-3);
}
.aide-card__field:last-child { border-bottom: none; }
.aide-card__label {
  color: var(--text-tertiary);
  font-size: 12px;
  text-transform: capitalize;
  flex-shrink: 0;
}

/* ── Section (React component) ── */
.aide-section {
  margin-bottom: var(--space-6);
}
.aide-section__header {
  display: flex;
  align-items: center;
  gap: var(--space-2);
  cursor: pointer;
  padding: var(--space-1) 0;
  user-select: none;
}
.aide-section__icon {
  color: var(--text-tertiary);
  font-size: 12px;
  width: 14px;
  text-align: center;
  transition: transform 0.2s;
}
.aide-section__icon--collapsed {
  transform: rotate(-90deg);
}
.aide-section__title {
  font-family: var(--font-serif);
  font-size: clamp(24px, 3.5vw, 32px);
  font-weight: 400;
  line-height: 1.25;
  color: var(--text-primary);
}
.aide-section__content {
  margin-top: var(--space-3);
}
.aide-section__content--collapsed {
  display: none;
}

/* ── Checklist (React component) ── */
.aide-checklist {
  list-style: none;
  padding: 0;
  margin-bottom: var(--space-4);
}
.aide-checklist__item {
  display: flex;
  align-items: flex-start;
  gap: var(--space-3);
  padding: var(--space-3) 0;
  border-bottom: 1px solid var(--border-light);
  font-size: 15px;
  line-height: 1.5;
}
.aide-checklist__item:last-child { border-bottom: none; }
.aide-checklist__checkbox {
  width: 16px;
  height: 16px;
  cursor: pointer;
  accent-color: var(--accent-navy);
  flex-shrink: 0;
  margin-top: 2px;
}
.aide-checklist__label {
  font-weight: 500;
  color: var(--text-primary);
}
.aide-checklist__label--done {
  text-decoration: line-through;
  color: var(--text-tertiary);
}
.aide-checklist__summary {
  font-size: 13px;
  color: var(--text-tertiary);
  padding-top: var(--space-2);
}

/* ── Editable field (React component) ── */
.editable-field {
  cursor: text;
  border-radius: 2px;
  padding: 1px 2px;
  margin: -1px -2px;
  transition: background-color 0.15s;
}
.editable-field:hover {
  background-color: rgba(0, 0, 0, 0.04);
}
.editable-field--empty {
  color: var(--text-tertiary);
}
.editable-input {
  font: inherit;
  color: inherit;
  background: #fff;
  border: 1px solid var(--accent-steel);
  border-radius: 2px;
  padding: 1px 4px;
  margin: -2px -5px;
  outline: none;
  min-width: 60px;
}

/* ── Mount animation ── */
.aide-mount-animation {
  animation: aide-fade-in 0.2s ease-out;
}
@keyframes aide-fade-in {
  from { opacity: 0; transform: translateY(4px); }
  to   { opacity: 1; transform: translateY(0); }
}

/* ── Legacy editable support (for vanilla JS fallback) ── */
.editable-value {
  cursor: pointer;
  padding: 2px 4px;
  border-radius: 4px;
  display: inline;
}
.editable-value:hover {
  background: rgba(0, 0, 0, 0.04);
}

/* ── Fallback entity renderer ── */
.fb-entity {
  border-left: 2px solid var(--border);
  padding: 8px 0 8px 12px;
  margin: 4px 0;
}
.fb-header {
  display: flex;
  gap: 8px;
  align-items: baseline;
  margin-bottom: 4px;
}
.fb-id {
  font-weight: 600;
  color: var(--text-slate);
  font-size: 12px;
}
.fb-display {
  font-size: 11px;
  color: var(--text-tertiary);
}
.fb-props {
  display: grid;
  grid-template-columns: max-content 1fr;
  gap: 2px 12px;
  font-size: 12px;
  color: var(--text-secondary);
}
dt {
  font-weight: 500;
  color: var(--text-slate);
}
dd {
  color: var(--text-secondary);
  word-break: break-word;
}
  </script>
</head>
<body>

<!-- Auth screen -->
<div id="auth-screen">
  <div class="auth-card">
    <div>
      <div class="auth-title">AIde</div>
      <div class="auth-subtitle">Sign in to continue.</div>
    </div>
    <div id="auth-send-form" class="auth-form">
      <input id="email-input" class="form-input" type="email" placeholder="you@example.com" autocomplete="email" />
      <button id="send-link-btn" class="btn btn-primary" style="width:100%;justify-content:center;">Send magic link</button>
      <p id="auth-msg" class="auth-message"></p>
    </div>
    <div id="auth-sent-msg" style="display:none;text-align:center;">
      <p style="color:var(--text-muted);font-size:13px;">Check your email — link sent.</p>
    </div>
  </div>
</div>

<!-- Dashboard -->
<div id="dashboard">
  <div class="dashboard-header">
    <h1>AIde</h1>
    <button id="new-aide-btn" class="btn btn-primary">+ New AIde</button>
  </div>
  <div id="aide-grid" class="aide-grid"></div>
  <div id="empty-state" class="empty-state" style="display:none;">
    <p>Nothing yet.</p>
    <button class="btn btn-ghost" onclick="startNewAide()">Create your first AIde</button>
  </div>
</div>

<!-- Editor -->
<button id="editor-back">←</button>
<button id="publish-btn-floating">Publish</button>

<div id="editor">
  <iframe id="preview-frame" sandbox="allow-scripts allow-same-origin"></iframe>

  <div id="chat-overlay">
    <div id="history-panel"></div>
    <div id="input-bar">
      <div id="image-preview-strip"></div>
      <div id="thinking-indicator">
        <div class="thinking-dots"><span></span><span></span><span></span></div>
        <span id="thinking-text">Thinking</span>
      </div>
      <div class="input-row">
        <textarea
          id="message-input"
          rows="1"
          placeholder="Tell AIde what you're running…"
        ></textarea>
        <div class="input-actions">
          <button id="image-btn" class="action-btn" title="Attach image">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/>
              <polyline points="21 15 16 10 5 21"/>
            </svg>
          </button>
          <input id="image-file-input" type="file" accept="image/jpeg,image/png,image/webp,image/heic" style="display:none;" />
          <button id="stop-btn" class="action-btn" title="Stop" style="display:none;">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
              <rect x="6" y="6" width="12" height="12" rx="2"/>
            </svg>
          </button>
          <button id="send-btn" class="action-btn" title="Send">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
              <path d="M2 21L23 12 2 3v7l15 2-15 2z"/>
            </svg>
          </button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Drag overlay -->
<div id="drag-overlay">Drop image here</div>

<!-- Modal -->
<div id="modal-overlay">
  <div class="modal">
    <div class="modal-title" id="modal-title"></div>
    <div class="modal-desc" id="modal-desc"></div>
    <div id="modal-body"></div>
    <div class="modal-actions" id="modal-actions"></div>
  </div>
</div>

<script>
  // ── State ──────────────────────────────────────────
  let currentUser = null;
  let currentAideId = null;
  let pendingImage = null; // { dataUrl, base64 }
  let conversationHistory = []; // {role, content}
  let isSending = false;
  let pendingPreviewUrl = null; // Server-rendered preview to load when stream ends
  let pendingUserMessage = null; // Track user message for stream persistence
  let pendingVoiceResponse = ''; // Accumulate voice response for stream persistence

  // ── Entity Store ────────────────────────────────────
  // Holds the live entity graph populated by WebSocket deltas.
  const entityStore = {
    entities: {},   // id → entity data
    rootIds: [],    // top-level entity IDs (parent === 'root' or no parent)
    meta: {},       // page metadata (title, description, etc.)

    applyDelta(delta) {
      if (delta.type === 'entity.create') {
        this.entities[delta.id] = delta.data || {};
        const parent = (delta.data || {}).parent;
        if (!parent || parent === 'root') {
          if (!this.rootIds.includes(delta.id)) {
            this.rootIds.push(delta.id);
          }
        }
      } else if (delta.type === 'entity.update') {
        if (this.entities[delta.id]) {
          Object.assign(this.entities[delta.id], delta.data || {});
        } else {
          this.entities[delta.id] = delta.data || {};
        }
      } else if (delta.type === 'entity.remove') {
        delete this.entities[delta.id];
        this.rootIds = this.rootIds.filter(id => id !== delta.id);
      }
      // Update progress indicator with entity count
      updateStreamProgress();
    },

    getChildren(parentId) {
      return Object.entries(this.entities)
        .filter(([, e]) => e.parent === parentId)
        .map(([id]) => id);
    },

    reset() {
      this.entities = {};
      this.rootIds = [];
      this.meta = {};
    },
  };

  // ── Display utilities ───────────────────────────────
  function escapeAttr(s) {
    return String(s ?? '').replace(/&/g,'&amp;').replace(/"/g,'&quot;').replace(/'/g,'&#39;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
  }

  function formatLabel(key) {
    return key.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
  }

  // EditableField — renders as a span click-to-edit; edits posted via postMessage to parent
  function editableField(value, entityId, field, opts) {
    const cls = opts && opts.className ? ` ${opts.className}` : '';
    const display = String(value ?? '—');
    return `<span class="editable-value${cls}" data-entity-id="${escapeAttr(entityId)}" data-field="${escapeAttr(field)}" onclick="window.__startEdit(this)">${escapeHtml(display)}</span>`;
  }

  // Helper: get props from entity (v2 format nests props under entity.props)
  function getProps(entity) {
    return entity.props || {};
  }

  // ── Display Renderers ────────────────────────────────

  function renderPageDisplay(id) {
    const entity = entityStore.entities[id];
    if (!entity) return '';
    const p = getProps(entity);
    const title = p.title || p.name || 'Untitled';
    const children = entityStore.getChildren(id).map(renderEntity).join('');
    return `<div class="aide-page">
      <div class="page-title">${editableField(title, id, p.title !== undefined ? 'title' : 'name', { className: 'page-title' })}</div>
      <div class="page-content">${children}</div>
    </div>`;
  }

  function renderCardDisplay(id) {
    const entity = entityStore.entities[id];
    if (!entity) return '';
    const p = getProps(entity);
    const skipKeys = new Set(['_pos', '_schema', '_shape']);
    const name = p.name || p.title || '';
    const fields = Object.entries(p)
      .filter(([k]) => !k.startsWith('_') && !skipKeys.has(k) && k !== 'name' && k !== 'title')
      .map(([k, v]) => `<div class="card-field">
        <span class="field-label">${escapeHtml(formatLabel(k))}</span>
        ${editableField(v, id, k)}
      </div>`)
      .join('');
    const children = entityStore.getChildren(id).map(renderEntity).join('');
    return `<div class="aide-card">
      ${name ? `<div class="card-title">${editableField(name, id, p.title !== undefined ? 'title' : 'name')}</div>` : ''}
      ${fields}
      ${children}
    </div>`;
  }

  function renderSectionDisplay(id) {
    const entity = entityStore.entities[id];
    if (!entity) return '';
    const p = getProps(entity);
    const title = p.title || p.name || 'Section';
    const uid = `sec_${id.replace(/[^a-z0-9]/gi, '_')}`;
    const children = entityStore.getChildren(id).map(renderEntity).join('');
    return `<div class="aide-section" id="${escapeAttr(uid)}">
      <div class="section-header" onclick="window.__toggleSection('${escapeAttr(uid)}')">
        <span class="collapse-icon" id="${escapeAttr(uid)}_icon">▾</span>
        <span class="section-title">${editableField(title, id, p.title !== undefined ? 'title' : 'name')}</span>
      </div>
      <div class="section-content" id="${escapeAttr(uid)}_content">${children}</div>
    </div>`;
  }

  function renderTableDisplay(id) {
    const entity = entityStore.entities[id];
    if (!entity) return '';
    const children = entityStore.getChildren(id);
    if (children.length === 0) {
      return renderCardDisplay(id);
    }
    // Infer columns from child props
    const skipKeys = new Set(['_pos', '_schema', '_shape']);
    const colSet = new Set();
    children.forEach(cid => {
      const child = entityStore.entities[cid];
      const cp = child ? getProps(child) : {};
      Object.keys(cp).filter(k => !k.startsWith('_') && !skipKeys.has(k)).forEach(k => colSet.add(k));
    });
    const cols = Array.from(colSet);
    const thead = `<tr>${cols.map(c => `<th>${escapeHtml(formatLabel(c))}</th>`).join('')}</tr>`;
    const tbody = children.map(cid => {
      const child = entityStore.entities[cid];
      if (!child) return '';
      const cp = getProps(child);
      return `<tr>${cols.map(c => `<td>${editableField(cp[c], cid, c)}</td>`).join('')}</tr>`;
    }).join('');
    return `<div class="aide-table-wrap">
      <table class="aide-table">
        <thead>${thead}</thead>
        <tbody>${tbody}</tbody>
      </table>
    </div>`;
  }

  function renderChecklistDisplay(id) {
    const entity = entityStore.entities[id];
    if (!entity) return '';
    const children = entityStore.getChildren(id);
    if (children.length === 0) return renderCardDisplay(id);
    const items = children.map(cid => {
      const child = entityStore.entities[cid];
      if (!child) return '';
      const cp = getProps(child);
      const done = cp.done === true || cp.done === 'true' || cp.completed === true;
      const label = cp.task || cp.label || cp.name || cid;
      const labelField = cp.task !== undefined ? 'task' : (cp.label !== undefined ? 'label' : 'name');
      return `<div class="checklist-item${done ? ' done' : ''}">
        <input type="checkbox"${done ? ' checked' : ''} data-entity-id="${escapeAttr(cid)}" data-field="done" onchange="window.__toggleCheck(this)">
        <span class="item-label">${editableField(label, cid, labelField)}</span>
      </div>`;
    }).join('');
    return `<div class="aide-checklist">${items}</div>`;
  }

  function renderMetricDisplay(id) {
    const entity = entityStore.entities[id];
    if (!entity) return '';
    const p = getProps(entity);
    const value = p.value ?? p.count ?? p.total ?? '';
    const label = p.label || p.name || '';
    return `<div class="aide-metric">
      <div class="metric-value">${escapeHtml(String(value))}</div>
      ${label ? `<div class="metric-label">${escapeHtml(label)}</div>` : ''}
    </div>`;
  }

  function renderTextDisplay(id) {
    const entity = entityStore.entities[id];
    if (!entity) return '';
    const p = getProps(entity);
    const text = p.text || p.content || p.body || '';
    const field = p.text !== undefined ? 'text' : (p.content !== undefined ? 'content' : 'body');
    return `<div class="aide-text">${editableField(text, id, field)}</div>`;
  }

  function renderListDisplay(id) {
    const entity = entityStore.entities[id];
    if (!entity) return '';
    const p = getProps(entity);
    const ordered = p.ordered === true;
    const children = entityStore.getChildren(id);
    const Tag = ordered ? 'ol' : 'ul';
    let items;
    if (children.length > 0) {
      items = children.map(cid => {
        const child = entityStore.entities[cid];
        const cp = child ? getProps(child) : {};
        const text = cp.text || cp.label || cp.name || cid;
        return `<li>${editableField(text, cid, 'text')}</li>`;
      }).join('');
    } else {
      const itemsArr = p.items || [];
      items = itemsArr.map(item => `<li>${escapeHtml(String(item))}</li>`).join('');
    }
    return `<${Tag} class="aide-list">${items}</${Tag}>`;
  }

  function renderImageDisplay(id) {
    const entity = entityStore.entities[id];
    if (!entity) return '';
    const p = getProps(entity);
    const src = p.src || p.url || '';
    const caption = p.caption || '';
    return `<figure class="aide-image">
      ${src ? `<img src="${escapeAttr(src)}" alt="${escapeAttr(caption)}">` : ''}
      ${caption ? `<figcaption>${escapeHtml(caption)}</figcaption>` : ''}
    </figure>`;
  }

  function renderGridDisplay(id) {
    const entity = entityStore.entities[id];
    if (!entity) return '';
    const p = getProps(entity);
    const cols = p.cols || (p._shape && p._shape[1]) || 10;
    const children = entityStore.getChildren(id);
    const cells = children.length > 0
      ? children.map(cid => {
          const child = entityStore.entities[cid];
          const cp = child ? getProps(child) : {};
          const label = cp.label || cp.name || cp.claim || cid;
          const claimed = cp.claim || cp.claimed || cp.owner;
          return `<div class="grid-cell${claimed ? ' claimed' : ''}">${escapeHtml(String(label))}</div>`;
        }).join('')
      : '';
    return `<div class="aide-grid-display" style="grid-template-columns:repeat(${parseInt(cols, 10) || 10},1fr)">${cells}</div>`;
  }

  // ── FallbackDisplay ─────────────────────────────────
  function renderFallbackEntity(id, depth) {
    const entity = entityStore.entities[id];
    if (!entity) return '';
    const display = entity.display || 'entity';
    const props = Object.entries(entity)
      .filter(([k]) => !k.startsWith('_') && k !== 'parent' && k !== 'display')
      .map(([k, v]) => `<dt>${escapeHtml(k)}</dt><dd>${escapeHtml(typeof v === 'object' ? JSON.stringify(v) : String(v))}</dd>`)
      .join('');
    const children = entityStore.getChildren(id)
      .map(cid => renderFallbackEntity(cid, depth + 1))
      .join('');
    const indent = depth * 16;
    return `<div class="fb-entity" style="margin-left:${indent}px">
      <div class="fb-header"><span class="fb-id">${escapeHtml(id)}</span><span class="fb-display">[${escapeHtml(display)}]</span></div>
      ${props ? `<dl class="fb-props">${props}</dl>` : ''}
      ${children}
    </div>`;
  }

  // ── Display resolution ───────────────────────────────
  function resolveDisplay(entity) {
    const hint = (entity.display || '').toLowerCase();
    const id = entity._id || '';
    const props = getProps(entity);

    // Check hint first
    if (hint === 'page') return 'page';
    if (hint === 'card') return 'card';
    if (hint === 'table') return 'table';
    if (hint === 'checklist') return 'checklist';
    if (hint === 'section') return 'section';
    if (hint === 'metric') return 'metric';
    if (hint === 'text') return 'text';
    if (hint === 'list') return 'list';
    if (hint === 'image') return 'image';
    if (hint === 'grid') return 'grid';

    // Heuristics when no hint provided
    // Grid cell (has row/col)
    if (props.row !== undefined && props.col !== undefined) return 'card';

    // Checklist-like (has done/checked/completed boolean)
    if (typeof props.done === 'boolean' || typeof props.checked === 'boolean' || typeof props.completed === 'boolean') {
      return 'card';
    }

    // Metric (has value/count/total with few fields)
    if (props.value !== undefined || props.count !== undefined || props.total !== undefined) {
      if (Object.keys(props).filter(k => !k.startsWith('_')).length <= 3) {
        return 'metric';
      }
    }

    // Image
    if (props.src || props.url) return 'image';

    // Text block (only text field)
    if (props.text && Object.keys(props).filter(k => !k.startsWith('_')).length === 1) {
      return 'text';
    }

    // Default to card (clean display for most entities)
    return 'card';
  }

  function renderEntity(id) {
    const entity = entityStore.entities[id];
    if (!entity) return '';
    const displayType = resolveDisplay(entity);
    switch (displayType) {
      case 'page':      return renderPageDisplay(id);
      case 'card':      return renderCardDisplay(id);
      case 'table':     return renderTableDisplay(id);
      case 'checklist': return renderChecklistDisplay(id);
      case 'section':   return renderSectionDisplay(id);
      case 'metric':    return renderMetricDisplay(id);
      case 'text':      return renderTextDisplay(id);
      case 'list':      return renderListDisplay(id);
      case 'image':     return renderImageDisplay(id);
      case 'grid':      return renderGridDisplay(id);
      default:          return renderFallbackEntity(id, 0);
    }
  }

  // ── Preview HTML builder (React-based) ─────────────────────────────
  // React display components template - matches docs/eng_design/04_display_components.md
  const REACT_COMPONENTS_TEMPLATE = `
    const { useState, useContext, createContext, useMemo } = React;

    // ── Entity Context ────────────────────────────────────
    const EntityContext = createContext({ entities: {}, meta: {}, rootIds: [] });

    function useEntity(id) {
      const { entities } = useContext(EntityContext);
      return entities[id] || null;
    }

    function useChildren(parentId) {
      const { entities } = useContext(EntityContext);
      return Object.entries(entities)
        .filter(([, e]) => e.parent === parentId)
        .map(([id]) => id);
    }

    function useMeta() {
      const { meta } = useContext(EntityContext);
      return meta;
    }

    function useRootIds() {
      const { rootIds } = useContext(EntityContext);
      return rootIds;
    }

    // ── Helpers ────────────────────────────────────────────
    function humanize(str) {
      if (!str) return '';
      return str.replace(/_/g, ' ').replace(/\\b\\w/g, c => c.toUpperCase());
    }

    function getDisplayableProps(props) {
      if (!props) return {};
      const skip = new Set(['title', 'name', '_removed', '_styles', '_pos', '_schema', '_shape']);
      return Object.fromEntries(
        Object.entries(props).filter(([k]) => !k.startsWith('_') && !skip.has(k))
      );
    }

    function inferType(value) {
      if (typeof value === 'boolean') return 'boolean';
      if (typeof value === 'number') return 'number';
      if (typeof value === 'string' && /^\\d{4}-\\d{2}-\\d{2}/.test(value)) return 'date';
      return 'string';
    }

    function formatValue(value, type) {
      if (value === null || value === undefined) return '—';
      if (type === 'boolean') return value ? '✓' : '○';
      if (type === 'date' && typeof value === 'string') {
        try {
          const d = new Date(value);
          return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        } catch { return value; }
      }
      return String(value);
    }

    function deriveColumns(children, entities) {
      const cols = new Set();
      const skip = new Set(['_pos', '_schema', '_shape']);
      children.forEach(id => {
        const entity = entities[id];
        const props = entity?.props || {};
        Object.keys(props).filter(k => !k.startsWith('_') && !skip.has(k)).forEach(k => cols.add(k));
      });
      return Array.from(cols);
    }

    function applyStyles(styles) {
      if (!styles) return {};
      const css = {};
      if (styles.bg_color) css.backgroundColor = styles.bg_color;
      if (styles.text_color) css.color = styles.text_color;
      return css;
    }

    // ── EditableField ──────────────────────────────────────
    function EditableField({ entityId, field, value, type = 'string', className = '' }) {
      const [editing, setEditing] = useState(false);
      const [draft, setDraft] = useState(value ?? '');

      const emitUpdate = (newValue) => {
        window.parent.postMessage({
          type: 'direct_edit',
          entity_id: entityId,
          field: field,
          value: newValue
        }, '*');
      };

      // Booleans toggle immediately
      if (type === 'boolean') {
        return React.createElement('input', {
          type: 'checkbox',
          className: 'aide-checklist__checkbox',
          checked: !!value,
          onChange: () => emitUpdate(!value)
        });
      }

      if (!editing) {
        const displayValue = formatValue(value, type);
        const isEmpty = value === null || value === undefined || value === '';
        return React.createElement('span', {
          className: 'editable-field ' + (isEmpty ? 'editable-field--empty ' : '') + className,
          onClick: () => { setDraft(value ?? ''); setEditing(true); }
        }, displayValue);
      }

      return React.createElement('input', {
        type: type === 'number' ? 'number' : type === 'date' ? 'date' : 'text',
        className: 'editable-input',
        value: draft,
        autoFocus: true,
        onChange: (e) => setDraft(e.target.value),
        onBlur: () => {
          setEditing(false);
          if (draft !== value) {
            const coerced = type === 'number' ? Number(draft) : draft;
            emitUpdate(coerced);
          }
        },
        onKeyDown: (e) => {
          if (e.key === 'Enter') e.target.blur();
          if (e.key === 'Escape') { setDraft(value ?? ''); setEditing(false); }
        }
      });
    }

    // ── Display Components ─────────────────────────────────

    function PageDisplay({ entity, entityId, children }) {
      const props = entity?.props || {};
      const title = props.title || props.name || '';
      return React.createElement('div', { className: 'aide-page aide-mount-animation' },
        title && React.createElement('h1', { className: 'aide-heading aide-heading--1' },
          React.createElement(EditableField, { entityId, field: 'title', value: title })
        ),
        children || React.createElement('p', { className: 'aide-empty' }, 'Say something to get started.')
      );
    }

    function SectionDisplay({ entity, entityId, children }) {
      const [collapsed, setCollapsed] = useState(false);
      const props = entity?.props || {};
      const title = props.title || props.name || 'Section';

      return React.createElement('div', { className: 'aide-section aide-mount-animation' },
        React.createElement('div', {
          className: 'aide-section__header',
          onClick: () => setCollapsed(!collapsed)
        },
          React.createElement('span', {
            className: 'aide-section__icon' + (collapsed ? ' aide-section__icon--collapsed' : '')
          }, '▾'),
          React.createElement('span', { className: 'aide-section__title' },
            React.createElement(EditableField, { entityId, field: 'title', value: title })
          )
        ),
        React.createElement('div', {
          className: 'aide-section__content' + (collapsed ? ' aide-section__content--collapsed' : '')
        }, children || React.createElement('p', { className: 'aide-collection-empty' }, 'No items yet.'))
      );
    }

    function CardDisplay({ entity, entityId, children }) {
      const props = entity?.props || {};
      const title = props.title || props.name || '';
      const displayProps = getDisplayableProps(props);
      const styles = applyStyles(entity?._styles);

      return React.createElement('div', { className: 'aide-card aide-mount-animation', style: styles },
        title && React.createElement('div', { className: 'aide-card__title' },
          React.createElement(EditableField, { entityId, field: props.title !== undefined ? 'title' : 'name', value: title })
        ),
        Object.entries(displayProps).map(([key, value]) =>
          React.createElement('div', { key, className: 'aide-card__field' },
            React.createElement('span', { className: 'aide-card__label' }, humanize(key)),
            React.createElement(EditableField, { entityId, field: key, value, type: inferType(value) })
          )
        ),
        children
      );
    }

    function ListDisplay({ entity, entityId, children }) {
      const props = entity?.props || {};
      const title = props.title || props.name || '';

      return React.createElement('div', { className: 'aide-mount-animation' },
        title && React.createElement('h3', { className: 'aide-heading aide-heading--3' },
          React.createElement(EditableField, { entityId, field: 'title', value: title })
        ),
        React.createElement('ul', { className: 'aide-list' },
          children || React.createElement('li', { className: 'aide-collection-empty' }, 'No items yet.')
        )
      );
    }

    function TableDisplay({ entity, entityId, children }) {
      const { entities } = useContext(EntityContext);
      const childIds = useChildren(entityId);
      const props = entity?.props || {};
      const title = props.title || props.name || '';

      if (childIds.length === 0) {
        return React.createElement(CardDisplay, { entity, entityId, children });
      }

      const columns = deriveColumns(childIds, entities);

      return React.createElement('div', { className: 'aide-mount-animation' },
        title && React.createElement('h3', { className: 'aide-heading aide-heading--3' },
          React.createElement(EditableField, { entityId, field: 'title', value: title })
        ),
        React.createElement('div', { className: 'aide-table-wrap' },
          React.createElement('table', { className: 'aide-table' },
            React.createElement('thead', null,
              React.createElement('tr', null,
                columns.map(col =>
                  React.createElement('th', { key: col, className: 'aide-table__th' }, humanize(col))
                )
              )
            ),
            React.createElement('tbody', null,
              childIds.map(cid => {
                const child = entities[cid];
                const cp = child?.props || {};
                return React.createElement('tr', { key: cid, className: 'aide-mount-animation' },
                  columns.map(col =>
                    React.createElement('td', { key: col, className: 'aide-table__td aide-table__td--' + inferType(cp[col]) },
                      React.createElement(EditableField, { entityId: cid, field: col, value: cp[col], type: inferType(cp[col]) })
                    )
                  )
                );
              })
            )
          )
        )
      );
    }

    function ChecklistDisplay({ entity, entityId, children }) {
      const { entities } = useContext(EntityContext);
      const childIds = useChildren(entityId);
      const props = entity?.props || {};
      const title = props.title || props.name || '';

      if (childIds.length === 0) {
        return React.createElement(CardDisplay, { entity, entityId, children });
      }

      const completed = childIds.filter(cid => {
        const cp = entities[cid]?.props || {};
        return cp.done === true || cp.checked === true || cp.completed === true;
      }).length;

      return React.createElement('div', { className: 'aide-mount-animation' },
        title && React.createElement('h3', { className: 'aide-heading aide-heading--3' },
          React.createElement(EditableField, { entityId, field: 'title', value: title })
        ),
        React.createElement('div', { className: 'aide-checklist' },
          childIds.map(cid => {
            const child = entities[cid];
            const cp = child?.props || {};
            const done = cp.done === true || cp.checked === true || cp.completed === true;
            const label = cp.task || cp.label || cp.name || cid;
            const labelField = cp.task !== undefined ? 'task' : (cp.label !== undefined ? 'label' : 'name');

            return React.createElement('div', { key: cid, className: 'aide-checklist__item aide-mount-animation' },
              React.createElement(EditableField, { entityId: cid, field: 'done', value: done, type: 'boolean' }),
              React.createElement('span', {
                className: 'aide-checklist__label' + (done ? ' aide-checklist__label--done' : '')
              },
                React.createElement(EditableField, { entityId: cid, field: labelField, value: label })
              )
            );
          })
        ),
        React.createElement('div', { className: 'aide-checklist__summary' },
          completed + ' of ' + childIds.length + ' complete'
        )
      );
    }

    function MetricDisplay({ entity, entityId }) {
      const props = entity?.props || {};
      const value = props.value ?? props.count ?? props.total ?? '';
      const label = props.label || props.name || '';
      const styles = applyStyles(entity?._styles);

      return React.createElement('div', { className: 'aide-metric aide-mount-animation', style: styles },
        React.createElement('span', { className: 'aide-metric__label' }, label),
        React.createElement('span', { className: 'aide-metric__value' },
          React.createElement(EditableField, { entityId, field: 'value', value, type: inferType(value) })
        )
      );
    }

    function TextDisplay({ entity, entityId }) {
      const props = entity?.props || {};
      const text = props.text || props.content || props.body || '';
      const field = props.text !== undefined ? 'text' : (props.content !== undefined ? 'content' : 'body');

      return React.createElement('p', { className: 'aide-text aide-mount-animation' },
        React.createElement(EditableField, { entityId, field, value: text })
      );
    }

    function ImageDisplay({ entity, entityId }) {
      const props = entity?.props || {};
      const src = props.src || props.url || '';
      const caption = props.caption || '';

      return React.createElement('figure', { className: 'aide-image aide-mount-animation' },
        src && React.createElement('img', { src, alt: caption, loading: 'lazy' }),
        caption && React.createElement('figcaption', { className: 'aide-image__caption' },
          React.createElement(EditableField, { entityId, field: 'caption', value: caption })
        )
      );
    }

    function FallbackDisplay({ entity, entityId, children }) {
      const props = entity?.props || {};
      const displayProps = Object.entries(props).filter(([k]) => !k.startsWith('_'));

      return React.createElement('div', { className: 'aide-card aide-mount-animation' },
        displayProps.map(([key, value]) =>
          React.createElement('div', { key, className: 'aide-card__field' },
            React.createElement('span', { className: 'aide-card__label' }, humanize(key)),
            React.createElement(EditableField, { entityId, field: key, value, type: inferType(value) })
          )
        ),
        children
      );
    }

    // ── Display Resolution ─────────────────────────────────
    const DISPLAY_COMPONENTS = {
      page: PageDisplay,
      section: SectionDisplay,
      card: CardDisplay,
      list: ListDisplay,
      table: TableDisplay,
      checklist: ChecklistDisplay,
      metric: MetricDisplay,
      text: TextDisplay,
      image: ImageDisplay
    };

    function resolveDisplay(entity, childIds, entities) {
      const hint = (entity?.display || '').toLowerCase();
      if (DISPLAY_COMPONENTS[hint]) return DISPLAY_COMPONENTS[hint];

      // Heuristics based on props and children
      const props = entity?.props || {};

      // Image
      if (props.src || props.url) return ImageDisplay;

      // Checklist items have done/checked/completed - leaf nodes
      if (typeof props.done === 'boolean' || typeof props.checked === 'boolean' || typeof props.completed === 'boolean') {
        return CardDisplay;
      }

      // Metric (few fields with value/count)
      if ((props.value !== undefined || props.count !== undefined) && Object.keys(props).filter(k => !k.startsWith('_')).length <= 3) {
        return MetricDisplay;
      }

      // Text block
      if (props.text && Object.keys(props).filter(k => !k.startsWith('_')).length === 1) {
        return TextDisplay;
      }

      // If entity has multiple children, render as table or checklist
      if (childIds && childIds.length > 0 && entities) {
        const firstChild = entities[childIds[0]];
        const cp = firstChild?.props || {};
        // Check if children are checklist items
        if (typeof cp.done === 'boolean' || typeof cp.checked === 'boolean' || typeof cp.completed === 'boolean') {
          return ChecklistDisplay;
        }
        // Multiple children with props → table
        return TableDisplay;
      }

      return CardDisplay;
    }

    // ── AideEntity (recursive renderer) ────────────────────
    function AideEntity({ entityId }) {
      const { entities } = useContext(EntityContext);
      const entity = useEntity(entityId);
      const childIds = useChildren(entityId);
      const Component = resolveDisplay(entity, childIds, entities);

      if (!entity || entity._removed) return null;

      // For table/checklist displays, don't recursively render children
      // - the component handles its own child rendering
      const shouldPassChildren = Component !== TableDisplay && Component !== ChecklistDisplay;
      const children = (shouldPassChildren && childIds.length > 0)
        ? childIds.map(id => React.createElement(AideEntity, { key: id, entityId: id }))
        : null;

      return React.createElement(Component, { entity, entityId }, children);
    }

    // ── PreviewApp (root) ──────────────────────────────────
    function PreviewApp() {
      const meta = useMeta();
      const rootIds = useRootIds();

      return React.createElement('main', { className: 'aide-page' },
        meta.title && React.createElement('h1', { className: 'aide-heading aide-heading--1' }, meta.title),
        rootIds.length > 0
          ? rootIds.map(id => React.createElement(AideEntity, { key: id, entityId: id }))
          : React.createElement('p', { className: 'aide-empty' }, 'Send a message to get started.')
      );
    }
  `;

  function buildPreviewHtml() {
    const css = document.getElementById('renderer-css-template').textContent;

    // Serialize entity store for React
    const entitiesJson = JSON.stringify(entityStore.entities);
    const metaJson = JSON.stringify(entityStore.meta);
    const rootIdsJson = JSON.stringify(entityStore.rootIds);

    return `<!DOCTYPE html>
<html><head><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,400;0,500;0,600;1,400&family=IBM+Plex+Sans:wght@300;400;500&display=swap" rel="stylesheet">
<script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"><` + `/script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"><` + `/script>
<style>${css}</style>
</head><body>
<div id="root"></div>
<script>
const INITIAL_ENTITIES = ${entitiesJson};
const INITIAL_META = ${metaJson};
const INITIAL_ROOT_IDS = ${rootIdsJson};

${REACT_COMPONENTS_TEMPLATE}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  React.createElement(EntityContext.Provider, {
    value: { entities: INITIAL_ENTITIES, meta: INITIAL_META, rootIds: INITIAL_ROOT_IDS }
  },
    React.createElement(PreviewApp)
  )
);
<` + `/script>
</body></html>`;
  }

  function refreshEntityPreview() {
    const frame = document.getElementById('preview-frame');
    // Only use entity preview when we have live entity data from WebSocket
    if (entityStore.rootIds.length > 0) {
      frame.srcdoc = buildPreviewHtml();
    }
  }

  // ── WebSocket Client ────────────────────────────────
  let aideWs = null;
  let wsConnectedAideId = null;

  function connectWebSocket(aideId) {
    // Close existing connection if switching aides
    if (aideWs && wsConnectedAideId !== aideId) {
      aideWs.close();
      aideWs = null;
    }
    if (aideWs && aideWs.readyState === WebSocket.OPEN) {
      return Promise.resolve();
    }

    const wsId = aideId || 'new';
    const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
    const url = `${proto}//${location.host}/ws/aide/${wsId}`;

    return new Promise((resolve, reject) => {
      try {
        aideWs = new WebSocket(url);
        wsConnectedAideId = wsId;

        aideWs.onopen = () => {
          console.log('[WS] connected:', url);
          resolve();
        };

      let isHydrating = false; // Track if we're receiving initial snapshot

      aideWs.onmessage = (event) => {
        let msg;
        try { msg = JSON.parse(event.data); } catch { return; }

        if (msg.type === 'snapshot.start') {
          // Beginning of initial snapshot hydration - reset store
          isHydrating = true;
          entityStore.reset();
          console.log('[WS] Hydrating snapshot...');
        } else if (msg.type === 'snapshot.end') {
          // End of snapshot hydration - refresh preview once
          isHydrating = false;
          refreshEntityPreview();
          console.log('[WS] Snapshot hydrated:', Object.keys(entityStore.entities).length, 'entities');
        } else if (msg.type === 'stream.start') {
          // Don't reset entityStore - keep existing entities for follow-up messages
          // Only reset voice accumulator for new stream
          pendingVoiceResponse = '';
        } else if (msg.type === 'entity.create' || msg.type === 'entity.update' || msg.type === 'entity.remove') {
          entityStore.applyDelta(msg);
          // Only refresh preview during streaming, not during hydration (wait for snapshot.end)
          if (!isHydrating) {
            refreshEntityPreview();
          }
        } else if (msg.type === 'meta.update') {
          // Update page metadata (title, etc.)
          if (msg.data) {
            entityStore.meta = msg.data;
            if (!isHydrating) {
              refreshEntityPreview();
            }
          }
        } else if (msg.type === 'voice') {
          // Show voice text as assistant message in history
          if (msg.text) {
            // Track for persistence (use last voice message as the response)
            pendingVoiceResponse = msg.text;
            // Only add if not already the last assistant message
            const last = conversationHistory[conversationHistory.length - 1];
            if (!last || last.role !== 'assistant' || last.content !== msg.text) {
              conversationHistory.push({ role: 'assistant', content: msg.text });
              renderHistory();
              // Smooth scroll to show new voice message
              const historyPanel = document.getElementById('history-panel');
              if (historyPanel.classList.contains('open')) {
                historyPanel.scrollTo({
                  top: historyPanel.scrollHeight,
                  behavior: 'smooth'
                });
              }
            }
          }
        } else if (msg.type === 'direct_edit.error') {
          console.warn('[WS] direct_edit rejected:', msg.error);
        } else if (msg.type === 'stream.interrupted') {
          console.log('[WS] stream interrupted by user');
          setSendingState(false);
          isSending = false;
        } else if (msg.type === 'stream.end') {
          setSendingState(false);
          isSending = false;
          pendingPreviewUrl = null;

          // Save conversation history only (server saves snapshot in ws.py)
          if (currentAideId && (pendingUserMessage || pendingVoiceResponse)) {
            fetch(`/api/aides/${currentAideId}/conversation`, {
              method: 'POST',
              credentials: 'include',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                message: pendingUserMessage,
                response: pendingVoiceResponse,
              }),
            })
            .then(() => {
              // Clear pending conversation after successful save
              pendingUserMessage = null;
              pendingVoiceResponse = '';
            })
            .catch(err => console.error('Failed to save conversation:', err));
          }
        } else if (msg.type === 'stream.error') {
          const errMsg = msg.error || 'Stream error.';
          conversationHistory.push({ role: 'assistant', content: errMsg });
          renderHistory();
          setSendingState(false);
          isSending = false;
        }
      };

      aideWs.onerror = (err) => {
        console.warn('[WS] error, will fall back to HTTP:', err);
        reject(err);
      };

      aideWs.onclose = () => {
        console.log('[WS] disconnected');
        if (wsConnectedAideId === wsId) {
          aideWs = null;
        }
      };
    } catch (err) {
      console.warn('[WS] could not connect:', err);
      aideWs = null;
      reject(err);
    }
    });
  }

  function sendViaWebSocket(content, messageId) {
    if (!aideWs || aideWs.readyState !== WebSocket.OPEN) return false;
    aideWs.send(JSON.stringify({ type: 'message', content, message_id: messageId }));
    return true;
  }

  function sendDirectEdit(entityId, field, value) {
    if (!aideWs || aideWs.readyState !== WebSocket.OPEN) {
      console.warn('[WS] direct_edit: no open connection');
      return;
    }
    aideWs.send(JSON.stringify({ type: 'direct_edit', entity_id: entityId, field, value }));
  }

  // Listen for postMessage from the preview iframe (direct edits + checkbox toggles)
  window.addEventListener('message', (event) => {
    if (!event.data || typeof event.data !== 'object') return;
    if (event.data.type === 'direct_edit') {
      const { entity_id, field, value } = event.data;
      sendDirectEdit(entity_id, field, value);
    }
  });

  // ── Screens ────────────────────────────────────────
  function showScreen(name) {
    document.getElementById('auth-screen').classList.toggle('active', name === 'auth');
    document.getElementById('dashboard').classList.toggle('active', name === 'dashboard');
    document.getElementById('editor').classList.toggle('active', name === 'editor');
    document.getElementById('editor-back').classList.toggle('visible', name === 'editor');
    document.getElementById('publish-btn-floating').classList.toggle('visible', name === 'editor');
  }

  // ── Auth ───────────────────────────────────────────
  async function checkAuth() {
    try {
      const res = await fetch('/auth/me', { credentials: 'include' });
      if (res.ok) {
        currentUser = await res.json();
        // Check if there's an aide ID in the URL
        const aideId = new URLSearchParams(location.search).get('aide');
        console.log('[URL Debug] Page load - URL aide param:', aideId, 'Full URL:', location.href);
        if (aideId) {
          openEditor(aideId);
        } else {
          loadDashboard();
        }
      } else {
        showScreen('auth');
      }
    } catch {
      showScreen('auth');
    }
  }

  document.getElementById('send-link-btn').addEventListener('click', async () => {
    const email = document.getElementById('email-input').value.trim();
    const msg = document.getElementById('auth-msg');
    if (!email) { msg.textContent = 'Enter your email.'; msg.className = 'auth-message error'; return; }

    const btn = document.getElementById('send-link-btn');
    btn.disabled = true;
    msg.textContent = '';

    try {
      const res = await fetch('/auth/send', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email }),
      });
      if (res.ok) {
        document.getElementById('auth-send-form').style.display = 'none';
        document.getElementById('auth-sent-msg').style.display = 'block';
      } else {
        const data = await res.json();
        msg.textContent = data.detail || 'Something went wrong.';
        msg.className = 'auth-message error';
        btn.disabled = false;
      }
    } catch {
      msg.textContent = 'Network error.';
      msg.className = 'auth-message error';
      btn.disabled = false;
    }
  });

  document.getElementById('email-input').addEventListener('keydown', e => {
    if (e.key === 'Enter') document.getElementById('send-link-btn').click();
  });

  // ── Dashboard ──────────────────────────────────────
  async function loadDashboard() {
    showScreen('dashboard');
    const grid = document.getElementById('aide-grid');
    const empty = document.getElementById('empty-state');
    grid.innerHTML = '';

    try {
      const res = await fetch('/api/aides', { credentials: 'include' });
      if (!res.ok) { showScreen('auth'); return; }
      const aides = await res.json();

      if (aides.length === 0) {
        empty.style.display = 'block';
        return;
      }

      empty.style.display = 'none';
      aides.forEach(aide => {
        const card = createAideCard(aide);
        grid.appendChild(card);
      });
    } catch {
      empty.style.display = 'block';
    }
  }

  function createAideCard(aide) {
    const card = document.createElement('div');
    card.className = 'aide-card';

    const updated = new Date(aide.updated_at).toLocaleDateString('en-US', {
      month: 'short', day: 'numeric', year: 'numeric'
    });

    card.innerHTML = `
      <div class="aide-card-title">${escapeHtml(aide.title)}</div>
      <div class="aide-card-meta">
        <span class="status-badge status-${aide.status}">${aide.status}</span>
        <span>${updated}</span>
      </div>
      <div class="aide-card-actions">
        <button class="icon-btn danger" title="Archive" data-id="${aide.id}">×</button>
      </div>
    `;

    card.addEventListener('click', (e) => {
      if (e.target.closest('.aide-card-actions')) return;
      openEditor(aide.id);
    });

    card.querySelector('.icon-btn.danger').addEventListener('click', async (e) => {
      e.stopPropagation();
      const confirmed = await confirmModal('Archive aide?', `"${aide.title}" will be archived.`, 'Archive');
      if (!confirmed) return;
      await archiveAide(aide.id);
    });

    return card;
  }

  async function archiveAide(aideId) {
    await fetch(`/api/aides/${aideId}/archive`, { method: 'POST', credentials: 'include' });
    loadDashboard();
  }

  function startNewAide() {
    openEditor(null);
  }

  document.getElementById('new-aide-btn').addEventListener('click', startNewAide);

  // ── Editor ─────────────────────────────────────────
  async function openEditor(aideId) {
    console.log('[URL Debug] openEditor called with aideId:', aideId);
    currentAideId = aideId;
    conversationHistory = [];
    pendingImage = null;

    renderHistory();
    clearImagePreview();
    document.getElementById('message-input').value = '';

    const frame = document.getElementById('preview-frame');

    if (aideId) {
      // Update URL to include aide ID (for refresh persistence)
      history.replaceState({}, '', `?aide=${aideId}`);

      // Existing AIde - load preview and conversation history
      frame.removeAttribute('srcdoc');
      frame.src = `/api/aides/${aideId}/preview`;

      // Load conversation history
      try {
        const res = await fetch(`/api/aides/${aideId}/history`, { credentials: 'include' });
        if (res.ok) {
          const data = await res.json();
          conversationHistory = data.messages || [];
          renderHistory();
        }
      } catch (e) {
        console.error('Failed to load conversation history:', e);
      }
    } else {
      // New AIde - show placeholder
      frame.srcdoc = '<html><body style="background:#f9f9f9;display:flex;align-items:center;justify-content:center;height:100vh;font-family:sans-serif;color:#aaa;font-size:14px;">Send a message to get started.</body></html>';
    }

    showScreen('editor');
    document.getElementById('message-input').focus();

    // Connect WebSocket for real-time entity streaming
    // WebSocket will send snapshot.start/snapshot.end to hydrate entityStore
    connectWebSocket(aideId);
  }

  document.getElementById('editor-back').addEventListener('click', () => {
    currentAideId = null;
    history.replaceState({}, '', '/');
    loadDashboard();
  });

  // ── Publish ────────────────────────────────────────
  document.getElementById('publish-btn-floating').addEventListener('click', async () => {
    if (!currentAideId) return;

    const slug = await promptModal('Publish', 'Enter a URL slug for your page:', 'my-page');
    if (!slug) return;

    try {
      const res = await fetch(`/api/aides/${currentAideId}/publish`, {
        method: 'POST',
        credentials: 'include',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ slug }),
      });
      if (res.ok) {
        const data = await res.json();
        await alertModal('Published', `Your page is live at: ${data.url}`);
      } else {
        const data = await res.json();
        await alertModal('Error', data.detail || 'Could not publish.');
      }
    } catch {
      await alertModal('Error', 'Network error.');
    }
  });

  // ── Sending messages ───────────────────────────────
  async function sendMessage() {
    if (isSending) return;
    const input = document.getElementById('message-input');
    const text = input.value.trim();
    if (!text && !pendingImage) return;

    isSending = true;
    setSendingState(true);

    const userContent = text || '(image)';
    conversationHistory.push({ role: 'user', content: userContent });
    renderHistory();

    input.value = '';
    resizeTextarea(input);

    const messageId = 'msg_' + Math.random().toString(36).slice(2, 10);
    clearImagePreview();

    // If new aide, create it first to get aide_id immediately
    if (!currentAideId) {
      try {
        const createRes = await fetch('/api/aides', {
          method: 'POST',
          credentials: 'include',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ title: 'Untitled' }),
        });
        if (createRes.ok) {
          const aideData = await createRes.json();
          currentAideId = aideData.id;
          history.replaceState({}, '', `?aide=${aideData.id}`);
          // Reconnect WebSocket with real aide ID and wait for it
          await connectWebSocket(aideData.id);
        } else if (createRes.status === 401) {
          showScreen('auth');
          return;
        }
      } catch (err) {
        console.error('Failed to create aide:', err);
      }
    }

    // Try WebSocket first (streaming entity deltas)
    const sentViaWs = !pendingImage && sendViaWebSocket(text, messageId);

    if (sentViaWs) {
      // Track user message for persistence at stream.end
      pendingUserMessage = text;
      // WebSocket handles streaming. State persistence happens at stream.end
      // via POST /api/aides/{id}/state (no duplicate LLM call)
      return;
    }

    // Fallback: HTTP-only path (used when no image support in WS or WS unavailable)
    const body = {
      aide_id: currentAideId || undefined,
      message: text || ' ',
      image: pendingImage ? pendingImage.base64 : undefined,
    };

    try {
      const res = await fetch('/api/message', {
        method: 'POST',
        credentials: 'include',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
      });

      if (res.status === 401) { showScreen('auth'); return; }

      const data = await res.json();

      if (!res.ok) {
        conversationHistory.push({ role: 'assistant', content: data.detail || 'Error.' });
        renderHistory();
        return;
      }

      // Update state
      currentAideId = data.aide_id;
      // Update URL for new AIde (persist across refresh)
      history.replaceState({}, '', `?aide=${data.aide_id}`);

      if (data.response_text) {
        conversationHistory.push({ role: 'assistant', content: data.response_text });
        renderHistory();
      }

      // Refresh preview: use page_url if accessible, otherwise fetch HTML
      refreshPreview(data.page_url);

    } catch (e) {
      conversationHistory.push({ role: 'assistant', content: 'Network error.' });
      renderHistory();
    } finally {
      isSending = false;
      setSendingState(false);
    }
  }

  async function refreshPreview(pageUrl) {
    // Load the preview URL in the iframe
    // Preview URL is now a backend proxy endpoint that handles auth
    const frame = document.getElementById('preview-frame');
    if (pageUrl) {
      // Fetch the HTML first, then swap srcdoc seamlessly (no blank flash)
      try {
        const res = await fetch(pageUrl, { credentials: 'include' });
        if (res.ok) {
          const html = await res.text();
          frame.srcdoc = html;
        }
      } catch (e) {
        console.warn('Preview fetch failed:', e);
      }
    }
  }

  let thinkingInterval = null;
  const thinkingStates = ['Thinking', 'Processing', 'Generating'];

  function updateStreamProgress() {
    // Update progress indicator with entity count during streaming
    if (isSending) {
      const count = Object.keys(entityStore.entities).length;
      const thinkingText = document.getElementById('thinking-text');
      if (count > 0) {
        thinkingText.textContent = `Building (${count} items)`;
      }
    }
  }

  function setSendingState(sending) {
    const sendBtn = document.getElementById('send-btn');
    const stopBtn = document.getElementById('stop-btn');
    const messageInput = document.getElementById('message-input');
    const indicator = document.getElementById('thinking-indicator');
    const thinkingText = document.getElementById('thinking-text');

    // Toggle between send and stop buttons
    sendBtn.style.display = sending ? 'none' : '';
    stopBtn.style.display = sending ? '' : 'none';
    messageInput.disabled = sending;

    if (sending) {
      indicator.classList.add('visible');
      let stateIndex = 0;
      thinkingText.textContent = thinkingStates[0];
      thinkingInterval = setInterval(() => {
        stateIndex = (stateIndex + 1) % thinkingStates.length;
        thinkingText.textContent = thinkingStates[stateIndex];
      }, 2000);
    } else {
      indicator.classList.remove('visible');
      if (thinkingInterval) {
        clearInterval(thinkingInterval);
        thinkingInterval = null;
      }
    }
  }

  // ── History ────────────────────────────────────────
  function renderHistory() {
    const panel = document.getElementById('history-panel');
    if (conversationHistory.length === 0) {
      panel.classList.remove('open');
      panel.innerHTML = '';
      return;
    }

    panel.innerHTML = conversationHistory.map(m => `
      <div class="history-message ${m.role}">
        <div class="history-content">${escapeHtml(m.content)}</div>
      </div>
    `).join('');

    panel.classList.add('open');
    // Delay scroll to allow panel to expand
    setTimeout(() => {
      panel.scrollTop = panel.scrollHeight;
    }, 50);
  }

  // ── Image handling ─────────────────────────────────
  document.getElementById('image-btn').addEventListener('click', () => {
    document.getElementById('image-file-input').click();
  });

  document.getElementById('image-file-input').addEventListener('change', e => {
    const file = e.target.files[0];
    if (file) handleImageFile(file);
    e.target.value = '';
  });

  function handleImageFile(file) {
    if (file.size > 10 * 1024 * 1024) { alert('Image must be under 10 MB.'); return; }
    const reader = new FileReader();
    reader.onload = ev => {
      const dataUrl = ev.target.result;
      const base64 = dataUrl.split(',')[1];
      pendingImage = { dataUrl, base64 };
      showImagePreview(dataUrl);
    };
    reader.readAsDataURL(file);
  }

  function showImagePreview(dataUrl) {
    const strip = document.getElementById('image-preview-strip');
    strip.innerHTML = `
      <div class="image-thumb">
        <img src="${dataUrl}" alt="attachment" />
        <button class="image-thumb-remove" id="remove-image-btn">×</button>
      </div>
    `;
    strip.classList.add('has-image');
    document.getElementById('remove-image-btn').addEventListener('click', clearImagePreview);
  }

  function clearImagePreview() {
    pendingImage = null;
    const strip = document.getElementById('image-preview-strip');
    strip.innerHTML = '';
    strip.classList.remove('has-image');
  }

  // Drag-and-drop
  let dragCounter = 0;
  document.addEventListener('dragenter', e => {
    if (e.dataTransfer.types.includes('Files')) {
      dragCounter++;
      document.getElementById('drag-overlay').classList.add('active');
    }
  });
  document.addEventListener('dragleave', () => {
    dragCounter--;
    if (dragCounter <= 0) {
      dragCounter = 0;
      document.getElementById('drag-overlay').classList.remove('active');
    }
  });
  document.addEventListener('dragover', e => e.preventDefault());
  document.addEventListener('drop', e => {
    e.preventDefault();
    dragCounter = 0;
    document.getElementById('drag-overlay').classList.remove('active');
    const file = e.dataTransfer.files[0];
    if (file && file.type.startsWith('image/')) handleImageFile(file);
  });

  // ── Input handlers ─────────────────────────────────
  const messageInput = document.getElementById('message-input');

  messageInput.addEventListener('input', () => resizeTextarea(messageInput));

  messageInput.addEventListener('keydown', e => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendMessage();
    }
  });

  document.getElementById('send-btn').addEventListener('click', sendMessage);

  // Stop button handler - interrupts the current stream
  document.getElementById('stop-btn').addEventListener('click', () => {
    if (aideWs && aideWs.readyState === WebSocket.OPEN) {
      aideWs.send(JSON.stringify({ type: 'interrupt' }));
    }
  });

  function resizeTextarea(el) {
    el.style.height = 'auto';
    el.style.height = Math.min(el.scrollHeight, 120) + 'px';
  }

  // ── Modals ─────────────────────────────────────────
  function openModal({ title, desc, body = '', actions }) {
    document.getElementById('modal-title').textContent = title;
    document.getElementById('modal-desc').textContent = desc;
    document.getElementById('modal-body').innerHTML = body;
    document.getElementById('modal-actions').innerHTML = actions;
    document.getElementById('modal-overlay').classList.add('active');
  }

  function closeModal() {
    document.getElementById('modal-overlay').classList.remove('active');
  }

  function confirmModal(title, desc, confirmLabel = 'Confirm') {
    return new Promise(resolve => {
      openModal({
        title, desc,
        actions: `
          <button class="btn btn-ghost" id="modal-cancel">Cancel</button>
          <button class="btn btn-danger" id="modal-confirm">${escapeHtml(confirmLabel)}</button>
        `,
      });
      document.getElementById('modal-cancel').onclick = () => { closeModal(); resolve(false); };
      document.getElementById('modal-confirm').onclick = () => { closeModal(); resolve(true); };
    });
  }

  function promptModal(title, desc, placeholder = '') {
    return new Promise(resolve => {
      openModal({
        title, desc,
        body: `<input id="modal-input" class="form-input" placeholder="${escapeHtml(placeholder)}" style="margin-top:4px;" />`,
        actions: `
          <button class="btn btn-ghost" id="modal-cancel">Cancel</button>
          <button class="btn btn-primary" id="modal-confirm">OK</button>
        `,
      });
      const inp = document.getElementById('modal-input');
      inp.focus();
      const submit = () => { const v = inp.value.trim(); closeModal(); resolve(v || null); };
      inp.addEventListener('keydown', e => { if (e.key === 'Enter') submit(); });
      document.getElementById('modal-cancel').onclick = () => { closeModal(); resolve(null); };
      document.getElementById('modal-confirm').onclick = submit;
    });
  }

  function alertModal(title, desc) {
    return new Promise(resolve => {
      openModal({
        title, desc,
        actions: `<button class="btn btn-primary" id="modal-ok">OK</button>`,
      });
      document.getElementById('modal-ok').onclick = () => { closeModal(); resolve(); };
    });
  }

  document.getElementById('modal-overlay').addEventListener('click', e => {
    if (e.target === document.getElementById('modal-overlay')) closeModal();
  });

  // ── Utils ──────────────────────────────────────────
  function escapeHtml(s) {
    return String(s)
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;');
  }

  // Handle magic link token in URL
  const urlParams = new URLSearchParams(location.search);
  const token = urlParams.get('token');
  if (token) {
    fetch(`/auth/verify?token=${encodeURIComponent(token)}`, { credentials: 'include' })
      .then(res => {
        history.replaceState({}, '', '/');
        if (res.ok) return res.json().then(user => { currentUser = user; loadDashboard(); });
        showScreen('auth');
      })
      .catch(() => showScreen('auth'));
  } else {
    checkAuth();
  }
</script>
</body>
</html>
