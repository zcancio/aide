{"version":3,"file":"XMLHttpRequest-BACqefB-.cjs","names":["handler: ProxyHandler<T>","next","FetchResponse","initialRequest: XMLHttpRequest","logger: Logger","createRequestId","encodeBuffer","INTERNAL_REQUEST_ID_HEADER_NAME","decodeBuffer","toArrayBuffer","RequestController","isResponseError","handleRequest","Interceptor","hasConfigurableGlobal","IS_PATCHED_MODULE"],"sources":["../../src/interceptors/XMLHttpRequest/utils/concatArrayBuffer.ts","../../src/interceptors/XMLHttpRequest/polyfills/EventPolyfill.ts","../../src/interceptors/XMLHttpRequest/polyfills/ProgressEventPolyfill.ts","../../src/interceptors/XMLHttpRequest/utils/createEvent.ts","../../src/utils/findPropertySource.ts","../../src/utils/createProxy.ts","../../src/interceptors/XMLHttpRequest/utils/isDomParserSupportedType.ts","../../src/utils/parseJson.ts","../../src/interceptors/XMLHttpRequest/utils/createResponse.ts","../../src/interceptors/XMLHttpRequest/utils/getBodyByteLength.ts","../../src/interceptors/XMLHttpRequest/XMLHttpRequestController.ts","../../src/interceptors/XMLHttpRequest/XMLHttpRequestProxy.ts","../../src/interceptors/XMLHttpRequest/index.ts"],"sourcesContent":["/**\n * Concatenate two `Uint8Array` buffers.\n */\nexport function concatArrayBuffer(\n  left: Uint8Array,\n  right: Uint8Array\n): Uint8Array {\n  const result = new Uint8Array(left.byteLength + right.byteLength)\n  result.set(left, 0)\n  result.set(right, left.byteLength)\n  return result\n}\n","export class EventPolyfill implements Event {\n  readonly NONE = 0\n  readonly CAPTURING_PHASE = 1\n  readonly AT_TARGET = 2\n  readonly BUBBLING_PHASE = 3\n\n  public type: string = ''\n  public srcElement: EventTarget | null = null\n  public target: EventTarget | null\n  public currentTarget: EventTarget | null = null\n  public eventPhase: number = 0\n  public timeStamp: number\n  public isTrusted: boolean = true\n  public composed: boolean = false\n  public cancelable: boolean = true\n  public defaultPrevented: boolean = false\n  public bubbles: boolean = true\n  public lengthComputable: boolean = true\n  public loaded: number = 0\n  public total: number = 0\n\n  cancelBubble: boolean = false\n  returnValue: boolean = true\n\n  constructor(\n    type: string,\n    options?: { target: EventTarget; currentTarget: EventTarget }\n  ) {\n    this.type = type\n    this.target = options?.target || null\n    this.currentTarget = options?.currentTarget || null\n    this.timeStamp = Date.now()\n  }\n\n  public composedPath(): EventTarget[] {\n    return []\n  }\n\n  public initEvent(type: string, bubbles?: boolean, cancelable?: boolean) {\n    this.type = type\n    this.bubbles = !!bubbles\n    this.cancelable = !!cancelable\n  }\n\n  public preventDefault() {\n    this.defaultPrevented = true\n  }\n\n  public stopPropagation() {}\n  public stopImmediatePropagation() {}\n}\n","import { EventPolyfill } from './EventPolyfill'\n\nexport class ProgressEventPolyfill extends EventPolyfill {\n  readonly lengthComputable: boolean\n  readonly composed: boolean\n  readonly loaded: number\n  readonly total: number\n\n  constructor(type: string, init?: ProgressEventInit) {\n    super(type)\n\n    this.lengthComputable = init?.lengthComputable || false\n    this.composed = init?.composed || false\n    this.loaded = init?.loaded || 0\n    this.total = init?.total || 0\n  }\n}\n","import { EventPolyfill } from '../polyfills/EventPolyfill'\nimport { ProgressEventPolyfill } from '../polyfills/ProgressEventPolyfill'\n\nconst SUPPORTS_PROGRESS_EVENT = typeof ProgressEvent !== 'undefined'\n\nexport function createEvent(\n  target: XMLHttpRequest | XMLHttpRequestUpload,\n  type: string,\n  init?: ProgressEventInit\n): EventPolyfill | ProgressEvent {\n  const progressEvents = [\n    'error',\n    'progress',\n    'loadstart',\n    'loadend',\n    'load',\n    'timeout',\n    'abort',\n  ]\n\n  /**\n   * `ProgressEvent` is not supported in React Native.\n   * @see https://github.com/mswjs/interceptors/issues/40\n   */\n  const ProgressEventClass = SUPPORTS_PROGRESS_EVENT\n    ? ProgressEvent\n    : ProgressEventPolyfill\n\n  const event = progressEvents.includes(type)\n    ? new ProgressEventClass(type, {\n        lengthComputable: true,\n        loaded: init?.loaded || 0,\n        total: init?.total || 0,\n      })\n    : new EventPolyfill(type, {\n        target,\n        currentTarget: target,\n      })\n\n  return event\n}\n","/**\n * Returns the source object of the given property on the target object\n * (the target itself, any parent in its prototype, or null).\n */\nexport function findPropertySource(\n  target: object,\n  propertyName: string | symbol\n): object | null {\n  if (!(propertyName in target)) {\n    return null\n  }\n\n  const hasProperty = Object.prototype.hasOwnProperty.call(target, propertyName)\n  if (hasProperty) {\n    return target\n  }\n\n  const prototype = Reflect.getPrototypeOf(target)\n  return prototype ? findPropertySource(prototype, propertyName) : null\n}\n","import { findPropertySource } from './findPropertySource'\n\nexport interface ProxyOptions<Target extends Record<string, any>> {\n  constructorCall?(args: Array<unknown>, next: NextFunction<Target>): Target\n\n  methodCall?<F extends keyof Target>(\n    this: Target,\n    data: [methodName: F, args: Array<unknown>],\n    next: NextFunction<void>\n  ): void\n\n  setProperty?(\n    data: [propertyName: string | symbol, nextValue: unknown],\n    next: NextFunction<boolean>\n  ): boolean\n\n  getProperty?(\n    data: [propertyName: string | symbol, receiver: Target],\n    next: NextFunction<void>\n  ): void\n}\n\nexport type NextFunction<ReturnType> = () => ReturnType\n\nexport function createProxy<Target extends object>(\n  target: Target,\n  options: ProxyOptions<Target>\n): Target {\n  const proxy = new Proxy(target, optionsToProxyHandler(options))\n\n  return proxy\n}\n\nfunction optionsToProxyHandler<T extends Record<string, any>>(\n  options: ProxyOptions<T>\n): ProxyHandler<T> {\n  const { constructorCall, methodCall, getProperty, setProperty } = options\n  const handler: ProxyHandler<T> = {}\n\n  if (typeof constructorCall !== 'undefined') {\n    handler.construct = function (target, args, newTarget) {\n      const next = Reflect.construct.bind(null, target as any, args, newTarget)\n      return constructorCall.call(newTarget, args, next)\n    }\n  }\n\n  handler.set = function (target, propertyName, nextValue) {\n    const next = () => {\n      const propertySource = findPropertySource(target, propertyName) || target\n      const ownDescriptors = Reflect.getOwnPropertyDescriptor(\n        propertySource,\n        propertyName\n      )\n\n      // Respect any custom setters present for this property.\n      if (typeof ownDescriptors?.set !== 'undefined') {\n        ownDescriptors.set.apply(target, [nextValue])\n        return true\n      }\n\n      // Otherwise, set the property on the source.\n      return Reflect.defineProperty(propertySource, propertyName, {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value: nextValue,\n      })\n    }\n\n    if (typeof setProperty !== 'undefined') {\n      return setProperty.call(target, [propertyName, nextValue], next)\n    }\n\n    return next()\n  }\n\n  handler.get = function (target, propertyName, receiver) {\n    /**\n     * @note Using `Reflect.get()` here causes \"TypeError: Illegal invocation\".\n     */\n    const next = () => target[propertyName as any]\n\n    const value =\n      typeof getProperty !== 'undefined'\n        ? getProperty.call(target, [propertyName, receiver], next)\n        : next()\n\n    if (typeof value === 'function') {\n      return (...args: Array<any>) => {\n        const next = value.bind(target, ...args)\n\n        if (typeof methodCall !== 'undefined') {\n          return methodCall.call(target, [propertyName as any, args], next)\n        }\n\n        return next()\n      }\n    }\n\n    return value\n  }\n\n  return handler\n}\n","export function isDomParserSupportedType(\n  type: string\n): type is DOMParserSupportedType {\n  const supportedTypes: Array<DOMParserSupportedType> = [\n    'application/xhtml+xml',\n    'application/xml',\n    'image/svg+xml',\n    'text/html',\n    'text/xml',\n  ]\n  return supportedTypes.some((supportedType) => {\n    return type.startsWith(supportedType)\n  })\n}\n","/**\n * Parses a given string into JSON.\n * Gracefully handles invalid JSON by returning `null`.\n */\nexport function parseJson(data: string): Record<string, unknown> | null {\n  try {\n    const json = JSON.parse(data)\n    return json\n  } catch (_) {\n    return null\n  }\n}\n","import { FetchResponse } from '../../../utils/fetchUtils'\n\n/**\n * Creates a Fetch API `Response` instance from the given\n * `XMLHttpRequest` instance and a response body.\n */\nexport function createResponse(\n  request: XMLHttpRequest,\n  body: BodyInit | null\n): Response {\n  /**\n   * Handle XMLHttpRequest responses that must have null as the\n   * response body when represented using Fetch API Response.\n   * XMLHttpRequest response will always have an empty string\n   * as the \"request.response\" in those cases, resulting in an error\n   * when constructing a Response instance.\n   * @see https://github.com/mswjs/interceptors/issues/379\n   */\n  const responseBodyOrNull = FetchResponse.isResponseWithBody(request.status)\n    ? body\n    : null\n\n  return new FetchResponse(responseBodyOrNull, {\n    url: request.responseURL,\n    status: request.status,\n    statusText: request.statusText,\n    headers: createHeadersFromXMLHttpRequestHeaders(\n      request.getAllResponseHeaders()\n    ),\n  })\n}\n\nfunction createHeadersFromXMLHttpRequestHeaders(headersString: string): Headers {\n  const headers = new Headers()\n\n  const lines = headersString.split(/[\\r\\n]+/)\n  for (const line of lines) {\n    if (line.trim() === '') {\n      continue\n    }\n\n    const [name, ...parts] = line.split(': ')\n    const value = parts.join(': ')\n\n    headers.append(name, value)\n  }\n\n  return headers\n}\n","/**\n * Return a total byte length of the given request/response body.\n * If the `Content-Length` header is present, it will be used as the byte length.\n */\nexport async function getBodyByteLength(\n  input: Request | Response\n): Promise<number> {\n  const explicitContentLength = input.headers.get('content-length')\n\n  if (explicitContentLength != null && explicitContentLength !== '') {\n    return Number(explicitContentLength)\n  }\n\n  const buffer = await input.arrayBuffer()\n  return buffer.byteLength\n}\n","import { invariant } from 'outvariant'\nimport { isNodeProcess } from 'is-node-process'\nimport type { Logger } from '@open-draft/logger'\nimport { concatArrayBuffer } from './utils/concatArrayBuffer'\nimport { createEvent } from './utils/createEvent'\nimport {\n  decodeBuffer,\n  encodeBuffer,\n  toArrayBuffer,\n} from '../../utils/bufferUtils'\nimport { createProxy } from '../../utils/createProxy'\nimport { isDomParserSupportedType } from './utils/isDomParserSupportedType'\nimport { parseJson } from '../../utils/parseJson'\nimport { createResponse } from './utils/createResponse'\nimport { INTERNAL_REQUEST_ID_HEADER_NAME } from '../../Interceptor'\nimport { createRequestId } from '../../createRequestId'\nimport { getBodyByteLength } from './utils/getBodyByteLength'\nimport { setRawRequest } from '../../getRawRequest'\n\nconst kIsRequestHandled = Symbol('kIsRequestHandled')\nconst IS_NODE = isNodeProcess()\nconst kFetchRequest = Symbol('kFetchRequest')\n\n/**\n * An `XMLHttpRequest` instance controller that allows us\n * to handle any given request instance (e.g. responding to it).\n */\nexport class XMLHttpRequestController {\n  public request: XMLHttpRequest\n  public requestId: string\n  public onRequest?: (\n    this: XMLHttpRequestController,\n    args: {\n      request: Request\n      requestId: string\n    }\n  ) => Promise<void>\n  public onResponse?: (\n    this: XMLHttpRequestController,\n    args: {\n      response: Response\n      isMockedResponse: boolean\n      request: Request\n      requestId: string\n    }\n  ) => void;\n\n  [kIsRequestHandled]: boolean;\n  [kFetchRequest]?: Request\n  private method: string = 'GET'\n  private url: URL = null as any\n  private requestHeaders: Headers\n  private responseBuffer: Uint8Array\n  private events: Map<keyof XMLHttpRequestEventTargetEventMap, Array<Function>>\n  private uploadEvents: Map<\n    keyof XMLHttpRequestEventTargetEventMap,\n    Array<Function>\n  >\n\n  constructor(\n    readonly initialRequest: XMLHttpRequest,\n    public logger: Logger\n  ) {\n    this[kIsRequestHandled] = false\n\n    this.events = new Map()\n    this.uploadEvents = new Map()\n    this.requestId = createRequestId()\n    this.requestHeaders = new Headers()\n    this.responseBuffer = new Uint8Array()\n\n    this.request = createProxy(initialRequest, {\n      setProperty: ([propertyName, nextValue], invoke) => {\n        switch (propertyName) {\n          case 'ontimeout': {\n            const eventName = propertyName.slice(\n              2\n            ) as keyof XMLHttpRequestEventTargetEventMap\n\n            /**\n             * @note Proxy callbacks to event listeners because JSDOM has trouble\n             * translating these properties to callbacks. It seemed to be operating\n             * on events exclusively.\n             */\n            this.request.addEventListener(eventName, nextValue as any)\n\n            return invoke()\n          }\n\n          default: {\n            return invoke()\n          }\n        }\n      },\n      methodCall: ([methodName, args], invoke) => {\n        switch (methodName) {\n          case 'open': {\n            const [method, url] = args as [string, string | undefined]\n\n            if (typeof url === 'undefined') {\n              this.method = 'GET'\n              this.url = toAbsoluteUrl(method)\n            } else {\n              this.method = method\n              this.url = toAbsoluteUrl(url)\n            }\n\n            this.logger = this.logger.extend(`${this.method} ${this.url.href}`)\n            this.logger.info('open', this.method, this.url.href)\n\n            return invoke()\n          }\n\n          case 'addEventListener': {\n            const [eventName, listener] = args as [\n              keyof XMLHttpRequestEventTargetEventMap,\n              Function,\n            ]\n\n            this.registerEvent(eventName, listener)\n            this.logger.info('addEventListener', eventName, listener)\n\n            return invoke()\n          }\n\n          case 'setRequestHeader': {\n            const [name, value] = args as [string, string]\n            this.requestHeaders.set(name, value)\n\n            this.logger.info('setRequestHeader', name, value)\n\n            return invoke()\n          }\n\n          case 'send': {\n            const [body] = args as [\n              body?: XMLHttpRequestBodyInit | Document | null,\n            ]\n\n            this.request.addEventListener('load', () => {\n              if (typeof this.onResponse !== 'undefined') {\n                // Create a Fetch API Response representation of whichever\n                // response this XMLHttpRequest received. Note those may\n                // be either a mocked and the original response.\n                const fetchResponse = createResponse(\n                  this.request,\n                  /**\n                   * The `response` property is the right way to read\n                   * the ambiguous response body, as the request's \"responseType\" may differ.\n                   * @see https://xhr.spec.whatwg.org/#the-response-attribute\n                   */\n                  this.request.response\n                )\n\n                // Notify the consumer about the response.\n                this.onResponse.call(this, {\n                  response: fetchResponse,\n                  isMockedResponse: this[kIsRequestHandled],\n                  request: fetchRequest,\n                  requestId: this.requestId!,\n                })\n              }\n            })\n\n            const requestBody =\n              typeof body === 'string' ? encodeBuffer(body) : body\n\n            // Delegate request handling to the consumer.\n            const fetchRequest = this.toFetchApiRequest(requestBody)\n            this[kFetchRequest] = fetchRequest.clone()\n\n            /**\n             * @note Start request handling on the next tick so that the user\n             * could add event listeners for \"loadend\" before the interceptor fires it.\n             */\n            queueMicrotask(() => {\n              const onceRequestSettled =\n                this.onRequest?.call(this, {\n                  request: fetchRequest,\n                  requestId: this.requestId!,\n                }) || Promise.resolve()\n\n              onceRequestSettled.finally(() => {\n                // If the consumer didn't handle the request (called `.respondWith()`) perform it as-is.\n                if (!this[kIsRequestHandled]) {\n                  this.logger.info(\n                    'request callback settled but request has not been handled (readystate %d), performing as-is...',\n                    this.request.readyState\n                  )\n\n                  /**\n                   * @note Set the intercepted request ID on the original request in Node.js\n                   * so that if it triggers any other interceptors, they don't attempt\n                   * to process it once again.\n                   *\n                   * For instance, XMLHttpRequest is often implemented via \"http.ClientRequest\"\n                   * and we don't want for both XHR and ClientRequest interceptors to\n                   * handle the same request at the same time (e.g. emit the \"response\" event twice).\n                   */\n                  if (IS_NODE) {\n                    this.request.setRequestHeader(\n                      INTERNAL_REQUEST_ID_HEADER_NAME,\n                      this.requestId!\n                    )\n                  }\n\n                  return invoke()\n                }\n              })\n            })\n\n            break\n          }\n\n          default: {\n            return invoke()\n          }\n        }\n      },\n    })\n\n    /**\n     * Proxy the `.upload` property to gather the event listeners/callbacks.\n     */\n    define(\n      this.request,\n      'upload',\n      createProxy(this.request.upload, {\n        setProperty: ([propertyName, nextValue], invoke) => {\n          switch (propertyName) {\n            case 'onloadstart':\n            case 'onprogress':\n            case 'onaboart':\n            case 'onerror':\n            case 'onload':\n            case 'ontimeout':\n            case 'onloadend': {\n              const eventName = propertyName.slice(\n                2\n              ) as keyof XMLHttpRequestEventTargetEventMap\n\n              this.registerUploadEvent(eventName, nextValue as Function)\n            }\n          }\n\n          return invoke()\n        },\n        methodCall: ([methodName, args], invoke) => {\n          switch (methodName) {\n            case 'addEventListener': {\n              const [eventName, listener] = args as [\n                keyof XMLHttpRequestEventTargetEventMap,\n                Function,\n              ]\n              this.registerUploadEvent(eventName, listener)\n              this.logger.info('upload.addEventListener', eventName, listener)\n\n              return invoke()\n            }\n          }\n        },\n      })\n    )\n  }\n\n  private registerEvent(\n    eventName: keyof XMLHttpRequestEventTargetEventMap,\n    listener: Function\n  ): void {\n    const prevEvents = this.events.get(eventName) || []\n    const nextEvents = prevEvents.concat(listener)\n    this.events.set(eventName, nextEvents)\n\n    this.logger.info('registered event \"%s\"', eventName, listener)\n  }\n\n  private registerUploadEvent(\n    eventName: keyof XMLHttpRequestEventTargetEventMap,\n    listener: Function\n  ): void {\n    const prevEvents = this.uploadEvents.get(eventName) || []\n    const nextEvents = prevEvents.concat(listener)\n    this.uploadEvents.set(eventName, nextEvents)\n\n    this.logger.info('registered upload event \"%s\"', eventName, listener)\n  }\n\n  /**\n   * Responds to the current request with the given\n   * Fetch API `Response` instance.\n   */\n  public async respondWith(response: Response): Promise<void> {\n    /**\n     * @note Since `XMLHttpRequestController` delegates the handling of the responses\n     * to the \"load\" event listener that doesn't distinguish between the mocked and original\n     * responses, mark the request that had a mocked response with a corresponding symbol.\n     *\n     * Mark this request as having a mocked response immediately since\n     * calculating request/response total body length is asynchronous.\n     */\n    this[kIsRequestHandled] = true\n\n    /**\n     * Dispatch request upload events for requests with a body.\n     * @see https://github.com/mswjs/interceptors/issues/573\n     */\n    if (this[kFetchRequest]) {\n      const totalRequestBodyLength = await getBodyByteLength(\n        this[kFetchRequest]\n      )\n\n      this.trigger('loadstart', this.request.upload, {\n        loaded: 0,\n        total: totalRequestBodyLength,\n      })\n      this.trigger('progress', this.request.upload, {\n        loaded: totalRequestBodyLength,\n        total: totalRequestBodyLength,\n      })\n      this.trigger('load', this.request.upload, {\n        loaded: totalRequestBodyLength,\n        total: totalRequestBodyLength,\n      })\n\n      this.trigger('loadend', this.request.upload, {\n        loaded: totalRequestBodyLength,\n        total: totalRequestBodyLength,\n      })\n    }\n\n    this.logger.info(\n      'responding with a mocked response: %d %s',\n      response.status,\n      response.statusText\n    )\n\n    define(this.request, 'status', response.status)\n    define(this.request, 'statusText', response.statusText)\n    define(this.request, 'responseURL', this.url.href)\n\n    this.request.getResponseHeader = new Proxy(this.request.getResponseHeader, {\n      apply: (_, __, args: [name: string]) => {\n        this.logger.info('getResponseHeader', args[0])\n\n        if (this.request.readyState < this.request.HEADERS_RECEIVED) {\n          this.logger.info('headers not received yet, returning null')\n\n          // Headers not received yet, nothing to return.\n          return null\n        }\n\n        const headerValue = response.headers.get(args[0])\n        this.logger.info(\n          'resolved response header \"%s\" to',\n          args[0],\n          headerValue\n        )\n\n        return headerValue\n      },\n    })\n\n    this.request.getAllResponseHeaders = new Proxy(\n      this.request.getAllResponseHeaders,\n      {\n        apply: () => {\n          this.logger.info('getAllResponseHeaders')\n\n          if (this.request.readyState < this.request.HEADERS_RECEIVED) {\n            this.logger.info('headers not received yet, returning empty string')\n\n            // Headers not received yet, nothing to return.\n            return ''\n          }\n\n          const headersList = Array.from(response.headers.entries())\n          const allHeaders = headersList\n            .map(([headerName, headerValue]) => {\n              return `${headerName}: ${headerValue}`\n            })\n            .join('\\r\\n')\n\n          this.logger.info('resolved all response headers to', allHeaders)\n\n          return allHeaders\n        },\n      }\n    )\n\n    // Update the response getters to resolve against the mocked response.\n    Object.defineProperties(this.request, {\n      response: {\n        enumerable: true,\n        configurable: false,\n        get: () => this.response,\n      },\n      responseText: {\n        enumerable: true,\n        configurable: false,\n        get: () => this.responseText,\n      },\n      responseXML: {\n        enumerable: true,\n        configurable: false,\n        get: () => this.responseXML,\n      },\n    })\n\n    const totalResponseBodyLength = await getBodyByteLength(response.clone())\n\n    this.logger.info('calculated response body length', totalResponseBodyLength)\n\n    this.trigger('loadstart', this.request, {\n      loaded: 0,\n      total: totalResponseBodyLength,\n    })\n\n    this.setReadyState(this.request.HEADERS_RECEIVED)\n    this.setReadyState(this.request.LOADING)\n\n    const finalizeResponse = () => {\n      this.logger.info('finalizing the mocked response...')\n\n      this.setReadyState(this.request.DONE)\n\n      this.trigger('load', this.request, {\n        loaded: this.responseBuffer.byteLength,\n        total: totalResponseBodyLength,\n      })\n\n      this.trigger('loadend', this.request, {\n        loaded: this.responseBuffer.byteLength,\n        total: totalResponseBodyLength,\n      })\n    }\n\n    if (response.body) {\n      this.logger.info('mocked response has body, streaming...')\n\n      const reader = response.body.getReader()\n\n      const readNextResponseBodyChunk = async () => {\n        const { value, done } = await reader.read()\n\n        if (done) {\n          this.logger.info('response body stream done!')\n          finalizeResponse()\n          return\n        }\n\n        if (value) {\n          this.logger.info('read response body chunk:', value)\n          this.responseBuffer = concatArrayBuffer(this.responseBuffer, value)\n\n          this.trigger('progress', this.request, {\n            loaded: this.responseBuffer.byteLength,\n            total: totalResponseBodyLength,\n          })\n        }\n\n        readNextResponseBodyChunk()\n      }\n\n      readNextResponseBodyChunk()\n    } else {\n      finalizeResponse()\n    }\n  }\n\n  private responseBufferToText(): string {\n    return decodeBuffer(this.responseBuffer)\n  }\n\n  get response(): unknown {\n    this.logger.info(\n      'getResponse (responseType: %s)',\n      this.request.responseType\n    )\n\n    if (this.request.readyState !== this.request.DONE) {\n      return null\n    }\n\n    switch (this.request.responseType) {\n      case 'json': {\n        const responseJson = parseJson(this.responseBufferToText())\n        this.logger.info('resolved response JSON', responseJson)\n\n        return responseJson\n      }\n\n      case 'arraybuffer': {\n        const arrayBuffer = toArrayBuffer(this.responseBuffer)\n        this.logger.info('resolved response ArrayBuffer', arrayBuffer)\n\n        return arrayBuffer\n      }\n\n      case 'blob': {\n        const mimeType =\n          this.request.getResponseHeader('Content-Type') || 'text/plain'\n        const responseBlob = new Blob([this.responseBufferToText()], {\n          type: mimeType,\n        })\n\n        this.logger.info(\n          'resolved response Blob (mime type: %s)',\n          responseBlob,\n          mimeType\n        )\n\n        return responseBlob\n      }\n\n      default: {\n        const responseText = this.responseBufferToText()\n        this.logger.info(\n          'resolving \"%s\" response type as text',\n          this.request.responseType,\n          responseText\n        )\n\n        return responseText\n      }\n    }\n  }\n\n  get responseText(): string {\n    /**\n     * Throw when trying to read the response body as text when the\n     * \"responseType\" doesn't expect text. This just respects the spec better.\n     * @see https://xhr.spec.whatwg.org/#the-responsetext-attribute\n     */\n    invariant(\n      this.request.responseType === '' || this.request.responseType === 'text',\n      'InvalidStateError: The object is in invalid state.'\n    )\n\n    if (\n      this.request.readyState !== this.request.LOADING &&\n      this.request.readyState !== this.request.DONE\n    ) {\n      return ''\n    }\n\n    const responseText = this.responseBufferToText()\n    this.logger.info('getResponseText: \"%s\"', responseText)\n\n    return responseText\n  }\n\n  get responseXML(): Document | null {\n    invariant(\n      this.request.responseType === '' ||\n        this.request.responseType === 'document',\n      'InvalidStateError: The object is in invalid state.'\n    )\n\n    if (this.request.readyState !== this.request.DONE) {\n      return null\n    }\n\n    const contentType = this.request.getResponseHeader('Content-Type') || ''\n\n    if (typeof DOMParser === 'undefined') {\n      console.warn(\n        'Cannot retrieve XMLHttpRequest response body as XML: DOMParser is not defined. You are likely using an environment that is not browser or does not polyfill browser globals correctly.'\n      )\n      return null\n    }\n\n    if (isDomParserSupportedType(contentType)) {\n      return new DOMParser().parseFromString(\n        this.responseBufferToText(),\n        contentType\n      )\n    }\n\n    return null\n  }\n\n  public errorWith(error?: Error): void {\n    /**\n     * @note Mark this request as handled even if it received a mock error.\n     * This prevents the controller from trying to perform this request as-is.\n     */\n    this[kIsRequestHandled] = true\n    this.logger.info('responding with an error')\n\n    this.setReadyState(this.request.DONE)\n    this.trigger('error', this.request)\n    this.trigger('loadend', this.request)\n  }\n\n  /**\n   * Transitions this request's `readyState` to the given one.\n   */\n  private setReadyState(nextReadyState: number): void {\n    this.logger.info(\n      'setReadyState: %d -> %d',\n      this.request.readyState,\n      nextReadyState\n    )\n\n    if (this.request.readyState === nextReadyState) {\n      this.logger.info('ready state identical, skipping transition...')\n      return\n    }\n\n    define(this.request, 'readyState', nextReadyState)\n\n    this.logger.info('set readyState to: %d', nextReadyState)\n\n    if (nextReadyState !== this.request.UNSENT) {\n      this.logger.info('triggering \"readystatechange\" event...')\n\n      this.trigger('readystatechange', this.request)\n    }\n  }\n\n  /**\n   * Triggers given event on the `XMLHttpRequest` instance.\n   */\n  private trigger<\n    EventName extends keyof (XMLHttpRequestEventTargetEventMap & {\n      readystatechange: ProgressEvent<XMLHttpRequestEventTarget>\n    }),\n  >(\n    eventName: EventName,\n    target: XMLHttpRequest | XMLHttpRequestUpload,\n    options?: ProgressEventInit\n  ): void {\n    const callback = (target as XMLHttpRequest)[`on${eventName}`]\n    const event = createEvent(target, eventName, options)\n\n    this.logger.info('trigger \"%s\"', eventName, options || '')\n\n    // Invoke direct callbacks.\n    if (typeof callback === 'function') {\n      this.logger.info('found a direct \"%s\" callback, calling...', eventName)\n      callback.call(target as XMLHttpRequest, event)\n    }\n\n    // Invoke event listeners.\n    const events =\n      target instanceof XMLHttpRequestUpload ? this.uploadEvents : this.events\n\n    for (const [registeredEventName, listeners] of events) {\n      if (registeredEventName === eventName) {\n        this.logger.info(\n          'found %d listener(s) for \"%s\" event, calling...',\n          listeners.length,\n          eventName\n        )\n\n        listeners.forEach((listener) => listener.call(target, event))\n      }\n    }\n  }\n\n  /**\n   * Converts this `XMLHttpRequest` instance into a Fetch API `Request` instance.\n   */\n  private toFetchApiRequest(\n    body: XMLHttpRequestBodyInit | Document | null | undefined\n  ): Request {\n    this.logger.info('converting request to a Fetch API Request...')\n\n    // If the `Document` is used as the body of this XMLHttpRequest,\n    // set its inner text as the Fetch API Request body.\n    const resolvedBody =\n      body instanceof Document ? body.documentElement.innerText : body\n\n    const fetchRequest = new Request(this.url.href, {\n      method: this.method,\n      headers: this.requestHeaders,\n      /**\n       * @see https://xhr.spec.whatwg.org/#cross-origin-credentials\n       */\n      credentials: this.request.withCredentials ? 'include' : 'same-origin',\n      body: ['GET', 'HEAD'].includes(this.method.toUpperCase())\n        ? null\n        : resolvedBody,\n    })\n\n    const proxyHeaders = createProxy(fetchRequest.headers, {\n      methodCall: ([methodName, args], invoke) => {\n        // Forward the latest state of the internal request headers\n        // because the interceptor might have modified them\n        // without responding to the request.\n        switch (methodName) {\n          case 'append':\n          case 'set': {\n            const [headerName, headerValue] = args as [string, string]\n            this.request.setRequestHeader(headerName, headerValue)\n            break\n          }\n\n          case 'delete': {\n            const [headerName] = args as [string]\n            console.warn(\n              `XMLHttpRequest: Cannot remove a \"${headerName}\" header from the Fetch API representation of the \"${fetchRequest.method} ${fetchRequest.url}\" request. XMLHttpRequest headers cannot be removed.`\n            )\n            break\n          }\n        }\n\n        return invoke()\n      },\n    })\n    define(fetchRequest, 'headers', proxyHeaders)\n    setRawRequest(fetchRequest, this.request)\n\n    this.logger.info('converted request to a Fetch API Request!', fetchRequest)\n\n    return fetchRequest\n  }\n}\n\nfunction toAbsoluteUrl(url: string | URL): URL {\n  /**\n   * @note XMLHttpRequest interceptor may run in environments\n   * that implement XMLHttpRequest but don't implement \"location\"\n   * (for example, React Native). If that's the case, return the\n   * input URL as-is (nothing to be relative to).\n   * @see https://github.com/mswjs/msw/issues/1777\n   */\n  if (typeof location === 'undefined') {\n    return new URL(url)\n  }\n\n  return new URL(url.toString(), location.href)\n}\n\nfunction define(\n  target: object,\n  property: string | symbol,\n  value: unknown\n): void {\n  Reflect.defineProperty(target, property, {\n    // Ensure writable properties to allow redefining readonly properties.\n    writable: true,\n    enumerable: true,\n    value,\n  })\n}\n","import type { Logger } from '@open-draft/logger'\nimport { XMLHttpRequestEmitter } from '.'\nimport { RequestController } from '../../RequestController'\nimport { XMLHttpRequestController } from './XMLHttpRequestController'\nimport { handleRequest } from '../../utils/handleRequest'\nimport { isResponseError } from '../../utils/responseUtils'\n\nexport interface XMLHttpRequestProxyOptions {\n  emitter: XMLHttpRequestEmitter\n  logger: Logger\n}\n\n/**\n * Create a proxied `XMLHttpRequest` class.\n * The proxied class establishes spies on certain methods,\n * allowing us to intercept requests and respond to them.\n */\nexport function createXMLHttpRequestProxy({\n  emitter,\n  logger,\n}: XMLHttpRequestProxyOptions) {\n  const XMLHttpRequestProxy = new Proxy(globalThis.XMLHttpRequest, {\n    construct(target, args, newTarget) {\n      logger.info('constructed new XMLHttpRequest')\n\n      const originalRequest = Reflect.construct(\n        target,\n        args,\n        newTarget\n      ) as XMLHttpRequest\n\n      /**\n       * @note Forward prototype descriptors onto the proxied object.\n       * XMLHttpRequest is implemented in JSDOM in a way that assigns\n       * a bunch of descriptors, like \"set responseType()\" on the prototype.\n       * With this propagation, we make sure that those descriptors trigger\n       * when the user operates with the proxied request instance.\n       */\n      const prototypeDescriptors = Object.getOwnPropertyDescriptors(\n        target.prototype\n      )\n      for (const propertyName in prototypeDescriptors) {\n        Reflect.defineProperty(\n          originalRequest,\n          propertyName,\n          prototypeDescriptors[propertyName]\n        )\n      }\n\n      const xhrRequestController = new XMLHttpRequestController(\n        originalRequest,\n        logger\n      )\n\n      xhrRequestController.onRequest = async function ({ request, requestId }) {\n        const controller = new RequestController(request, {\n          passthrough: () => {\n            this.logger.info(\n              'no mocked response received, performing request as-is...'\n            )\n          },\n          respondWith: async (response) => {\n            if (isResponseError(response)) {\n              this.errorWith(new TypeError('Network error'))\n              return\n            }\n\n            await this.respondWith(response)\n          },\n          errorWith: (reason) => {\n            this.logger.info('request errored!', { error: reason })\n\n            if (reason instanceof Error) {\n              this.errorWith(reason)\n            }\n          },\n        })\n\n        this.logger.info('awaiting mocked response...')\n\n        this.logger.info(\n          'emitting the \"request\" event for %s listener(s)...',\n          emitter.listenerCount('request')\n        )\n\n        await handleRequest({\n          request,\n          requestId,\n          controller,\n          emitter,\n        })\n      }\n\n      xhrRequestController.onResponse = async function ({\n        response,\n        isMockedResponse,\n        request,\n        requestId,\n      }) {\n        this.logger.info(\n          'emitting the \"response\" event for %s listener(s)...',\n          emitter.listenerCount('response')\n        )\n\n        emitter.emit('response', {\n          response,\n          isMockedResponse,\n          request,\n          requestId,\n        })\n      }\n\n      // Return the proxied request from the controller\n      // so that the controller can react to the consumer's interactions\n      // with this request (opening/sending/etc).\n      return xhrRequestController.request\n    },\n  })\n\n  return XMLHttpRequestProxy\n}\n","import { invariant } from 'outvariant'\nimport { Emitter } from 'strict-event-emitter'\nimport { HttpRequestEventMap, IS_PATCHED_MODULE } from '../../glossary'\nimport { Interceptor } from '../../Interceptor'\nimport { createXMLHttpRequestProxy } from './XMLHttpRequestProxy'\nimport { hasConfigurableGlobal } from '../../utils/hasConfigurableGlobal'\n\nexport type XMLHttpRequestEmitter = Emitter<HttpRequestEventMap>\n\nexport class XMLHttpRequestInterceptor extends Interceptor<HttpRequestEventMap> {\n  static interceptorSymbol = Symbol('xhr')\n\n  constructor() {\n    super(XMLHttpRequestInterceptor.interceptorSymbol)\n  }\n\n  protected checkEnvironment() {\n    return hasConfigurableGlobal('XMLHttpRequest')\n  }\n\n  protected setup() {\n    const logger = this.logger.extend('setup')\n\n    logger.info('patching \"XMLHttpRequest\" module...')\n\n    const PureXMLHttpRequest = globalThis.XMLHttpRequest\n\n    invariant(\n      !(PureXMLHttpRequest as any)[IS_PATCHED_MODULE],\n      'Failed to patch the \"XMLHttpRequest\" module: already patched.'\n    )\n\n    globalThis.XMLHttpRequest = createXMLHttpRequestProxy({\n      emitter: this.emitter,\n      logger: this.logger,\n    })\n\n    logger.info(\n      'native \"XMLHttpRequest\" module patched!',\n      globalThis.XMLHttpRequest.name\n    )\n\n    Object.defineProperty(globalThis.XMLHttpRequest, IS_PATCHED_MODULE, {\n      enumerable: true,\n      configurable: true,\n      value: true,\n    })\n\n    this.subscriptions.push(() => {\n      Object.defineProperty(globalThis.XMLHttpRequest, IS_PATCHED_MODULE, {\n        value: undefined,\n      })\n\n      globalThis.XMLHttpRequest = PureXMLHttpRequest\n      logger.info(\n        'native \"XMLHttpRequest\" module restored!',\n        globalThis.XMLHttpRequest.name\n      )\n    })\n  }\n}\n"],"mappings":"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"}