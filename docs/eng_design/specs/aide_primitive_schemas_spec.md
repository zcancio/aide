# AIde — Primitive Schemas

**Purpose:** Exact JSON schemas for the 25 kernel primitives. This is what L2 emits, what the reducer consumes, and what the validation layer checks. Every state change in AIde goes through one of these.

**Companion docs:** `aide_architecture.md` (how primitives fit in the system), `aide_mvp_checklist.md` (build plan)

---

## Conventions

**All primitives are declarative.** They describe desired state, not actions. "Set this field to this value" not "move this from here to there."

**Refs** are `collection_id/entity_id` strings. Example: `"roster/player_mike"`, `"grocery_list/item_milk"`.

**IDs** are lowercase, snake_case, alphanumeric + underscores. Max 64 characters. Generated by the AI or auto-assigned by the system.

**Field types** supported in collection schemas:

| Type | JSON representation | Example |
|------|-------------------|---------|
| `string` | `"string"` | `"Mike"` |
| `string?` | `"string?"` | `"Mike"` or `null` |
| `int` | `"int"` | `20` |
| `int?` | `"int?"` | `20` or `null` |
| `float` | `"float"` | `9.99` |
| `float?` | `"float?"` | `9.99` or `null` |
| `bool` | `"bool"` | `true` |
| `date` | `"date"` | `"2026-02-27"` (ISO 8601) |
| `date?` | `"date?"` | `"2026-02-27"` or `null` |
| `datetime` | `"datetime"` | `"2026-02-27T19:00:00Z"` (ISO 8601) |
| `datetime?` | `"datetime?"` | `"2026-02-27T19:00:00Z"` or `null` |
| `enum` | `{"enum": ["a","b","c"]}` | `"a"` |
| `list` | `{"list": "string"}` | `["milk", "eggs"]` |

The `?` suffix means nullable. Fields without `?` are required when creating an entity. The reducer rejects `entity.create` if required fields are missing.

---

## Event Wrapper

Every primitive is wrapped in an event before entering the log. The primitive itself is the `type` + `payload`. The rest is metadata.

```json
{
  "id": "evt_20260227_003",
  "sequence": 3,
  "timestamp": "2026-02-27T14:30:00Z",
  "actor": "user_abc123",
  "source": "signal",
  "type": "entity.update",
  "payload": { ... },
  "intent": "substitution",
  "message": "Mike's out this week",
  "message_id": "msg_xyz"
}
```

| Field | Required | Description |
|-------|----------|-------------|
| `id` | yes | Unique event ID. Format: `evt_{date}_{sequence}` |
| `sequence` | yes | Monotonically increasing integer per aide |
| `timestamp` | yes | ISO 8601 datetime, UTC |
| `actor` | yes | User ID or `"system"` |
| `source` | yes | Which ear: `"web"`, `"signal"`, `"telegram"`, `"system"` |
| `type` | yes | Primitive type: `"entity.update"`, `"collection.create"`, etc. |
| `payload` | yes | Primitive-specific payload (schemas below) |
| `intent` | no | Semantic label: `"claim"`, `"substitution"`, `"check_off"`, etc. |
| `message` | no | Original user message that triggered this event |
| `message_id` | no | Reference to conversation message |

The reducer reads only `type` and `payload`. Everything else is metadata for the event log.

---

## Entity Primitives (1–3)

### 1. `entity.create`

Create a new entity in a collection.

```json
{
  "type": "entity.create",
  "payload": {
    "collection": "grocery_list",
    "id": "item_milk",
    "fields": {
      "name": "Milk",
      "store": "Whole Foods",
      "checked": false
    }
  }
}
```

| Field | Required | Type | Description |
|-------|----------|------|-------------|
| `collection` | yes | string | Target collection ID |
| `id` | no | string | Entity ID. Auto-generated if omitted. |
| `fields` | yes | object | Field values. Must conform to collection schema. Required (non-nullable) schema fields must be present. |

**Reducer behavior:** Adds entity to collection. Rejects if `id` already exists (use `entity.update` instead). Rejects if required schema fields are missing. Ignores fields not in schema.

### 2. `entity.update`

Update fields on an existing entity.

```json
{
  "type": "entity.update",
  "payload": {
    "ref": "roster/player_mike",
    "fields": {
      "status": "out"
    }
  }
}
```

| Field | Required | Type | Description |
|-------|----------|------|-------------|
| `ref` | yes* | string | Entity ref: `collection_id/entity_id` |
| `filter` | yes* | object | Alternative to `ref`: match entities by field values |
| `fields` | yes | object | Fields to update. Merged into existing fields. Unmentioned fields unchanged. |

*Provide `ref` or `filter`, not both.

**Filter example** (bulk update):
```json
{
  "type": "entity.update",
  "payload": {
    "filter": { "collection": "grocery_list", "where": { "checked": true } },
    "fields": { "archived": true }
  }
}
```

**Reducer behavior:** Merges `fields` into existing entity. Rejects if entity doesn't exist (not soft-deleted). Rejects if field values violate schema types.

### 3. `entity.remove`

Soft-delete an entity.

```json
{
  "type": "entity.remove",
  "payload": {
    "ref": "grocery_list/item_milk"
  }
}
```

| Field | Required | Type | Description |
|-------|----------|------|-------------|
| `ref` | yes | string | Entity ref |

**Reducer behavior:** Marks entity as removed. Removed entities are excluded from snapshot views and collection counts. Relationships involving removed entities are excluded. Entity data is preserved in the event log for undo.

---

## Collection Primitives (4–6)

### 4. `collection.create`

Create a new collection with a schema.

```json
{
  "type": "collection.create",
  "payload": {
    "id": "grocery_list",
    "name": "Grocery List",
    "schema": {
      "name": "string",
      "store": "string?",
      "category": "string?",
      "checked": "bool",
      "requested_by": "string?"
    },
    "settings": {}
  }
}
```

| Field | Required | Type | Description |
|-------|----------|------|-------------|
| `id` | yes | string | Collection ID (snake_case) |
| `name` | no | string | Display name. Defaults to titlecase of `id`. |
| `schema` | yes | object | Field name → field type mapping |
| `settings` | no | object | Collection-level settings (grid dimensions, capacity, etc.) |

**Reducer behavior:** Creates the collection in state. Rejects if `id` already exists.

### 5. `collection.update`

Update collection properties.

```json
{
  "type": "collection.update",
  "payload": {
    "id": "grocery_list",
    "name": "Weekly Groceries",
    "settings": { "default_store": "Whole Foods" }
  }
}
```

| Field | Required | Type | Description |
|-------|----------|------|-------------|
| `id` | yes | string | Collection ID |
| `name` | no | string | New display name |
| `settings` | no | object | Merged into existing settings |

**Reducer behavior:** Updates collection properties. Does not affect schema or entities. Rejects if collection doesn't exist.

### 6. `collection.remove`

Remove a collection and all its entities.

```json
{
  "type": "collection.remove",
  "payload": {
    "id": "grocery_list"
  }
}
```

| Field | Required | Type | Description |
|-------|----------|------|-------------|
| `id` | yes | string | Collection ID |

**Reducer behavior:** Soft-deletes the collection and all its entities. Removes related views and block references. Relationships involving entities in this collection are excluded.

---

## Field Primitives (7–9)

Schema evolution. These change the shape of a collection without affecting existing data.

### 7. `field.add`

Add a new field to a collection's schema.

```json
{
  "type": "field.add",
  "payload": {
    "collection": "grocery_list",
    "name": "category",
    "type": "string?",
    "default": null
  }
}
```

| Field | Required | Type | Description |
|-------|----------|------|-------------|
| `collection` | yes | string | Collection ID |
| `name` | yes | string | Field name (snake_case) |
| `type` | yes | string/object | Field type (see type table above) |
| `default` | no | any | Default value for existing entities. If omitted and type is nullable, defaults to `null`. If omitted and type is required, rejects. |

**Reducer behavior:** Adds field to schema. Existing entities get the default value for this field.

### 8. `field.update`

Change a field's properties.

```json
{
  "type": "field.update",
  "payload": {
    "collection": "grocery_list",
    "name": "category",
    "type": {"enum": ["produce", "dairy", "meat", "pantry", "other"]}
  }
}
```

| Field | Required | Type | Description |
|-------|----------|------|-------------|
| `collection` | yes | string | Collection ID |
| `name` | yes | string | Existing field name |
| `type` | no | string/object | New field type |
| `rename` | no | string | New field name |

**Reducer behavior:** Updates the field definition. Type changes must be compatible (string → enum is OK if all existing values match; int → string is OK; string → int rejects if existing values aren't numeric).

### 9. `field.remove`

Remove a field from a collection's schema.

```json
{
  "type": "field.remove",
  "payload": {
    "collection": "grocery_list",
    "name": "category"
  }
}
```

| Field | Required | Type | Description |
|-------|----------|------|-------------|
| `collection` | yes | string | Collection ID |
| `name` | yes | string | Field name to remove |

**Reducer behavior:** Removes field from schema. Existing entities lose this field's data from the snapshot (but it's preserved in the event log).

---

## Relationship Primitives (10–11)

### 10. `relationship.set`

Declare a link between two entities.

```json
{
  "type": "relationship.set",
  "payload": {
    "from": "roster/player_dave",
    "to": "schedule/game_feb27",
    "type": "hosting",
    "cardinality": "many_to_one"
  }
}
```

| Field | Required | Type | Description |
|-------|----------|------|-------------|
| `from` | yes | string | Source entity ref |
| `to` | yes | string | Target entity ref |
| `type` | yes | string | Relationship type name |
| `cardinality` | no | string | `"one_to_one"`, `"many_to_one"`, or `"many_to_many"`. Default: `"many_to_one"`. Only needed on first use of this relationship type — persisted after that. |
| `data` | no | object | Optional metadata on the relationship |

**Reducer behavior:** Creates or updates the relationship. For `many_to_one`: if the source entity already has a relationship of this type, the old one is automatically removed (e.g., "seat Linda at table 5" auto-removes her from table 3). For `one_to_one`: both sides are exclusive. Rejects if either entity doesn't exist.

### 11. `relationship.constrain`

Declare a rule about relationships.

```json
{
  "type": "relationship.constrain",
  "payload": {
    "id": "constraint_no_linda_steve",
    "rule": "exclude_pair",
    "entities": ["guests/guest_linda", "guests/guest_steve"],
    "relationship_type": "seated_at",
    "message": "Keep Linda and Steve at different tables"
  }
}
```

| Field | Required | Type | Description |
|-------|----------|------|-------------|
| `id` | yes | string | Constraint ID |
| `rule` | yes | string | Rule type: `"exclude_pair"`, `"require_same"`, `"max_per_target"`, `"min_per_target"` |
| `entities` | no | list | Entity refs involved (for pair-based rules) |
| `relationship_type` | yes | string | Which relationship type this constrains |
| `value` | no | int | Numeric value (for max/min rules) |
| `message` | no | string | Human-readable description |

**Reducer behavior:** Stores the constraint. On every subsequent `relationship.set`, checks all constraints. Violations produce a warning in the event response but do not block the change (unless strict mode is enabled on the constraint).

---

## Block Primitives (12–14)

### 12. `block.set`

Create or update a block in the page tree.

```json
{
  "type": "block.set",
  "payload": {
    "id": "block_next_game",
    "type": "metric",
    "parent": "block_root",
    "position": 1,
    "props": {
      "label": "Next game",
      "value": "Thu Feb 27 at Dave's"
    }
  }
}
```

| Field | Required | Type | Description |
|-------|----------|------|-------------|
| `id` | yes | string | Block ID |
| `type` | yes (on create) | string | Block type (see below) |
| `parent` | no | string | Parent block ID. Default: `"block_root"`. |
| `position` | no | int | Index among siblings. Appended to end if omitted. |
| `props` | no | object | Type-specific properties (see block types below) |

**Block types (v1):**

| Type | Props | Renders as |
|------|-------|-----------|
| `heading` | `level` (1–3), `content` | `<h1>`, `<h2>`, `<h3>` |
| `text` | `content` | `<p>` |
| `metric` | `label`, `value`, `trend?` | Key-value display |
| `collection_view` | `source` (collection ID), `view` (view ID) | Rendered collection |
| `divider` | — | `<hr>` |
| `image` | `src`, `alt?`, `caption?` | `<img>` |
| `callout` | `content`, `icon?` | Highlighted block |
| `column_list` | — | Flex container for columns |
| `column` | `width?` (e.g., `"50%"`, `"33%"`) | Flex child |

**Reducer behavior:** Creates block if `id` doesn't exist. Updates block if it does. Manages parent-child relationships. Inserting at a position shifts siblings.

### 13. `block.remove`

Remove a block from the page tree.

```json
{
  "type": "block.remove",
  "payload": {
    "id": "block_next_game"
  }
}
```

| Field | Required | Type | Description |
|-------|----------|------|-------------|
| `id` | yes | string | Block ID |

**Reducer behavior:** Removes block and all its children from the tree.

### 14. `block.reorder`

Reorder children within a parent block.

```json
{
  "type": "block.reorder",
  "payload": {
    "parent": "block_root",
    "children": ["block_title", "block_roster", "block_next_game", "block_schedule"]
  }
}
```

| Field | Required | Type | Description |
|-------|----------|------|-------------|
| `parent` | yes | string | Parent block ID |
| `children` | yes | list | Ordered list of child block IDs |

**Reducer behavior:** Sets the order of children. All IDs in `children` must be current children of the parent. Missing children are appended at the end. Extra IDs are ignored.

---

## View Primitives (15–17)

### 15. `view.create`

Create a new view of a collection.

```json
{
  "type": "view.create",
  "payload": {
    "id": "roster_view",
    "type": "list",
    "source": "roster",
    "config": {
      "show_fields": ["name", "status"],
      "hide_fields": ["snack_duty"],
      "sort_by": "name",
      "sort_order": "asc"
    }
  }
}
```

| Field | Required | Type | Description |
|-------|----------|------|-------------|
| `id` | yes | string | View ID |
| `type` | yes | string | View type: `"list"`, `"table"`, `"grid"`, `"calendar"`, `"kanban"`, `"dashboard"` |
| `source` | yes | string | Collection ID |
| `config` | no | object | View-specific configuration |

**Config options (all optional):**

| Option | Type | Description |
|--------|------|-------------|
| `show_fields` | list | Fields to show (whitelist) |
| `hide_fields` | list | Fields to hide (blacklist) |
| `sort_by` | string | Field to sort by |
| `sort_order` | string | `"asc"` or `"desc"` |
| `group_by` | string | Field to group by |
| `filter` | object | Field-value conditions to filter entities |
| `row_labels` | list | For grid views: row header labels |
| `col_labels` | list | For grid views: column header labels |
| `date_field` | string | For calendar views: which field is the date |
| `status_field` | string | For kanban views: which field defines columns |

**Reducer behavior:** Creates the view. Rejects if `source` collection doesn't exist.

### 16. `view.update`

Update view properties.

```json
{
  "type": "view.update",
  "payload": {
    "id": "roster_view",
    "config": {
      "show_fields": ["name", "status", "snack_duty"]
    }
  }
}
```

| Field | Required | Type | Description |
|-------|----------|------|-------------|
| `id` | yes | string | View ID |
| `type` | no | string | Change view type |
| `config` | no | object | Merged into existing config |

### 17. `view.remove`

Remove a view.

```json
{
  "type": "view.remove",
  "payload": {
    "id": "roster_view"
  }
}
```

| Field | Required | Type | Description |
|-------|----------|------|-------------|
| `id` | yes | string | View ID |

**Reducer behavior:** Removes the view. Block references to this view become invalid and should fall back to a default view.

---

## Style Primitives (18–19)

### 18. `style.set`

Set global style tokens.

```json
{
  "type": "style.set",
  "payload": {
    "primary_color": "#2d3748",
    "font_family": "Inter",
    "density": "comfortable",
    "bg_color": "#fafaf9"
  }
}
```

| Field | Required | Type | Description |
|-------|----------|------|-------------|
| (any key) | — | string | Token name → value. Merged into existing styles. |

**Known tokens (v1):**

| Token | Values | Default |
|-------|--------|---------|
| `primary_color` | hex color | `"#2d3748"` |
| `bg_color` | hex color | `"#fafaf9"` |
| `text_color` | hex color | `"#1a1a1a"` |
| `font_family` | font name | `"Inter"` |
| `heading_font` | font name | `"Cormorant Garamond"` |
| `density` | `"compact"`, `"comfortable"`, `"spacious"` | `"comfortable"` |

Unknown tokens are stored but ignored by the renderer until a future version supports them.

### 19. `style.set_entity`

Set per-entity visual overrides.

```json
{
  "type": "style.set_entity",
  "payload": {
    "ref": "roster/player_mike",
    "styles": {
      "highlight": true,
      "bg_color": "#fef3c7"
    }
  }
}
```

| Field | Required | Type | Description |
|-------|----------|------|-------------|
| `ref` | yes | string | Entity ref |
| `styles` | yes | object | Style overrides for this entity |

**Reducer behavior:** Stores style overrides alongside the entity. The renderer applies these when rendering the entity in a view.

---

## Meta Primitives (20–22)

### 20. `meta.update`

Update aide-level properties.

```json
{
  "type": "meta.update",
  "payload": {
    "title": "Poker League — Spring 2026",
    "identity": "Poker league. 8 players, biweekly Thursday, rotating hosts."
  }
}
```

| Field | Required | Type | Description |
|-------|----------|------|-------------|
| (any key) | — | any | Aide-level property. Merged into existing meta. |

**Known meta properties:**

| Property | Type | Description |
|----------|------|-------------|
| `title` | string | Aide display name (used in `<title>` tag) |
| `identity` | string | What this aide is (used in blueprint) |
| `visibility` | string | `"public"`, `"unlisted"`, `"private"` |
| `archived` | bool | Whether the aide is archived |

### 21. `meta.annotate`

Append a note to the aide's annotation log.

```json
{
  "type": "meta.annotate",
  "payload": {
    "note": "Host rotation advanced. Dave hosting Feb 27.",
    "pinned": false
  }
}
```

| Field | Required | Type | Description |
|-------|----------|------|-------------|
| `note` | yes | string | Human-readable note |
| `pinned` | no | bool | Whether to pin this note at the top of the history |

**Reducer behavior:** Appends to the annotation list in state. Pinned notes are rendered first.

### 22. `meta.constrain`

Declare an aide-level rule.

```json
{
  "type": "meta.constrain",
  "payload": {
    "id": "constraint_max_players",
    "rule": "collection_max_entities",
    "collection": "roster",
    "value": 10,
    "message": "Maximum 10 players"
  }
}
```

| Field | Required | Type | Description |
|-------|----------|------|-------------|
| `id` | yes | string | Constraint ID |
| `rule` | yes | string | Rule type: `"collection_max_entities"`, `"collection_min_entities"`, `"required_fields"`, `"unique_field"` |
| `collection` | no | string | Which collection (for collection-level rules) |
| `field` | no | string | Which field (for field-level rules) |
| `value` | no | any | Rule parameter |
| `message` | no | string | Human-readable description |

**Reducer behavior:** Stores the constraint. Validates on every subsequent entity create/update. Violations produce warnings.

---

## Reserved (23–25)

Primitives 23–25 are reserved for future use. Candidates:

- `trigger.create` — declare a condition that fires events (e.g., "notify when all items checked")
- `computed.set` — declare a derived value (e.g., "total = sum of amount where paid=true")
- `macro.invoke` — invoke a named MacroSpec by ID

These are not in v1.

---

## Validation Rules

The validation layer checks every primitive before it reaches the reducer.

### Universal checks (all primitives)
- `type` is one of the 22 known primitive types (or 25 when reserved are implemented)
- `payload` is a non-null object
- All string IDs match `^[a-z][a-z0-9_]{0,63}$`
- All refs match `^[a-z][a-z0-9_]{0,63}/[a-z][a-z0-9_]{0,63}$`

### Entity checks
- `entity.create`: collection exists, ID doesn't already exist, required fields present, field values match schema types
- `entity.update`: entity exists (not removed), field values match schema types
- `entity.remove`: entity exists

### Collection checks
- `collection.create`: ID doesn't already exist, schema is a valid type mapping
- `collection.update`: collection exists
- `collection.remove`: collection exists

### Field checks
- `field.add`: collection exists, field name doesn't already exist in schema
- `field.update`: collection exists, field exists in schema
- `field.remove`: collection exists, field exists in schema

### Relationship checks
- `relationship.set`: both entities exist
- `relationship.constrain`: referenced entities (if any) exist

### Block checks
- `block.set`: parent exists (or is `block_root`), type is known
- `block.remove`: block exists
- `block.reorder`: parent exists, all child IDs are current children

### View checks
- `view.create`: source collection exists
- `view.update`: view exists
- `view.remove`: view exists

### Invalid primitives
If validation fails, the primitive is rejected with an error. The event is not appended to the log. The orchestrator receives the error and can either retry (with L3) or report to the user.

---

## Escalation Signal

When L2 can't compile a user message into valid primitives, it returns an escalation instead:

```json
{
  "type": "escalation",
  "reason": "no_schema",
  "user_message": "we need milk, eggs, and sourdough",
  "context": "No collections exist. This is a new aide.",
  "attempted": null
}
```

| Reason | When |
|--------|------|
| `no_schema` | First message, no collections exist |
| `unknown_entity` | Referenced entity doesn't exist and can't be resolved |
| `unknown_field` | Field mentioned that's not in any schema |
| `novel_view` | Request for a view type that doesn't exist |
| `structural_change` | Request to reorganize the page layout |
| `ambiguous` | Can't determine intent with confidence |
| `complex_conditional` | Request involves logic beyond simple field updates |

The orchestrator forwards escalations to L3, which returns one or more valid primitives (or a MacroSpec).
