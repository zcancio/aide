# AIde — Primitive Schemas (v3)

**Purpose:** Exact JSON schemas for the kernel primitives. This is what L2 emits, what the reducer consumes, and what the validation layer checks. Every state change in AIde goes through one of these.

**Companion docs:** `aide_architecture.md` (how primitives fit in the system), `unified_entity_model.md` (v3 data model)

---

## Conventions

**All primitives are declarative.** They describe desired state, not actions. "Set this field to this value" not "move this from here to there."

**Paths** address entities hierarchically: `entity_id/field/child_id`. Example: `"grocery_list/items/item_milk"`.

**IDs** are lowercase, snake_case, alphanumeric + underscores. Max 64 characters. Generated by the AI or auto-assigned by the system.

**Schema IDs** are PascalCase to match TypeScript interface naming: `GroceryItem`, `PokerLeague`.

**TypeScript types** define entity schemas. The reducer parses TypeScript interfaces using tree-sitter and validates entity fields against them.

### TypeScript Type Mappings

| TypeScript | JSON Value | Notes |
|------------|------------|-------|
| `string` | `"text"` | Required string |
| `string?` or `string \| undefined` | `"text"` or absent | Optional |
| `string \| null` | `"text"` or `null` | Nullable |
| `number` | `5` or `4.99` | Integer or float |
| `boolean` | `true` / `false` | Boolean |
| `Date` | `"2026-02-27"` | ISO 8601 date string |
| `"a" \| "b" \| "c"` | `"a"` | Union/enum |
| `string[]` | `["a", "b"]` | Array |
| `Record<string, T>` | `{...}` | Child collection, each value is type `T` |

---

## Event Wrapper

Every primitive is wrapped in an event before entering the log. The primitive itself is the `type` + `payload`. The rest is metadata.

```json
{
  "id": "evt_20260227_003",
  "sequence": 3,
  "timestamp": "2026-02-27T14:30:00Z",
  "actor": "user_abc123",
  "source": "signal",
  "type": "entity.update",
  "payload": { ... },
  "intent": "substitution",
  "message": "Mike's out this week",
  "message_id": "msg_xyz"
}
```

| Field | Required | Description |
|-------|----------|-------------|
| `id` | yes | Unique event ID. Format: `evt_{date}_{sequence}` |
| `sequence` | yes | Monotonically increasing integer per aide |
| `timestamp` | yes | ISO 8601 datetime, UTC |
| `actor` | yes | User ID or `"system"` |
| `source` | yes | Which ear: `"web"`, `"signal"`, `"telegram"`, `"system"` |
| `type` | yes | Primitive type: `"entity.update"`, `"schema.create"`, etc. |
| `payload` | yes | Primitive-specific payload (schemas below) |
| `intent` | no | Semantic label: `"claim"`, `"substitution"`, `"check_off"`, etc. |
| `message` | no | Original user message that triggered this event |
| `message_id` | no | Reference to conversation message |

The reducer reads only `type` and `payload`. Everything else is metadata for the event log.

---

## Schema Primitives (1–3)

Schemas define entity types using TypeScript interfaces.

### 1. `schema.create`

Create a new schema (entity type).

```json
{
  "type": "schema.create",
  "payload": {
    "id": "GroceryItem",
    "interface": "interface GroceryItem { name: string; checked: boolean; store?: string; }",
    "render_html": "<li class=\"item {{#checked}}done{{/checked}}\">{{name}}</li>",
    "render_text": "{{#checked}}✓{{/checked}}{{^checked}}○{{/checked}} {{name}}",
    "styles": ".item { padding: 8px; } .item.done { opacity: 0.5; }"
  }
}
```

| Field | Required | Type | Description |
|-------|----------|------|-------------|
| `id` | yes | string | Schema ID (PascalCase) |
| `interface` | yes | string | TypeScript interface definition |
| `render_html` | no | string | Mustache template for HTML output |
| `render_text` | no | string | Mustache template for text/unicode output |
| `styles` | no | string | CSS for HTML rendering |

**Reducer behavior:** Parses the TypeScript interface using tree-sitter. Rejects if parsing fails or `id` already exists. Stores schema in `snapshot.schemas[id]`.

### 2. `schema.update`

Update an existing schema.

```json
{
  "type": "schema.update",
  "payload": {
    "id": "GroceryItem",
    "interface": "interface GroceryItem { name: string; checked: boolean; store?: string; price?: number; }",
    "render_html": "<li class=\"item\">{{name}}{{#price}} - ${{price}}{{/price}}</li>"
  }
}
```

| Field | Required | Type | Description |
|-------|----------|------|-------------|
| `id` | yes | string | Schema ID |
| `interface` | no | string | New TypeScript interface (replaces existing) |
| `render_html` | no | string | New HTML template |
| `render_text` | no | string | New text template |
| `styles` | no | string | New CSS |

**Reducer behavior:** Updates schema properties. Omitted fields are unchanged. Validates that all existing entities with `_schema: "GroceryItem"` still conform to the new interface. WARN if fields are missing (backward-compatible), REJECT if type conflicts.

### 3. `schema.remove`

Remove a schema.

```json
{
  "type": "schema.remove",
  "payload": {
    "id": "GroceryItem"
  }
}
```

| Field | Required | Type | Description |
|-------|----------|------|-------------|
| `id` | yes | string | Schema ID |

**Reducer behavior:** REJECT if any entities reference this schema (`_schema: "GroceryItem"`). Otherwise removes from `snapshot.schemas`.

---

## Entity Primitives (4–6)

Entities are the atoms of state. Every entity has a `_schema` that defines its type.

### 4. `entity.create`

Create a new entity.

```json
{
  "type": "entity.create",
  "payload": {
    "id": "grocery_list",
    "_schema": "GroceryList",
    "title": "Weekly Groceries",
    "items": {
      "item_milk": { "name": "Milk", "checked": false, "_pos": 1.0 },
      "item_eggs": { "name": "Eggs", "checked": false, "_pos": 2.0 }
    }
  }
}
```

| Field | Required | Type | Description |
|-------|----------|------|-------------|
| `id` | yes | string | Entity ID (snake_case) |
| `_schema` | yes | string | Schema ID this entity conforms to |
| `_pos` | no | number | Fractional position for ordering (among siblings) |
| `...fields` | yes | any | Field values matching the schema interface |

**Nested children:** If the schema has `Record<string, T>` fields, children can be inline:

```json
{
  "items": {
    "item_milk": { "name": "Milk", "checked": false, "_pos": 1.0 }
  }
}
```

Each child value is validated against schema `T`.

**Reducer behavior:** Validates fields against parsed TypeScript interface. Rejects if required fields missing, type mismatch, or `id` already exists. Stores entity in `snapshot.entities[id]`.

### 5. `entity.update`

Update an existing entity's fields and/or children.

```json
{
  "type": "entity.update",
  "payload": {
    "id": "grocery_list",
    "title": "This Week's Groceries",
    "items": {
      "item_milk": { "checked": true },
      "item_bread": { "name": "Bread", "checked": false, "_pos": 1.5 },
      "item_eggs": null
    }
  }
}
```

| Field | Required | Type | Description |
|-------|----------|------|-------------|
| `id` | yes | string | Entity ID or path (`grocery_list/items/item_milk`) |
| `...fields` | yes | any | Fields to update. Unmentioned fields unchanged. |

**Child updates in `Record<string, T>` fields:**
- `item_milk: { checked: true }` — update existing child
- `item_bread: { name: "Bread", ... }` — create new child (didn't exist)
- `item_eggs: null` — remove child

**Direct path update:**

```json
{
  "type": "entity.update",
  "payload": {
    "id": "grocery_list/items/item_milk",
    "checked": true
  }
}
```

**Reducer behavior:** Merges fields into existing entity. Validates against schema. For child collections, applies create/update/remove per child entry.

### 6. `entity.remove`

Soft-delete an entity.

```json
{
  "type": "entity.remove",
  "payload": {
    "id": "grocery_list/items/item_milk"
  }
}
```

| Field | Required | Type | Description |
|-------|----------|------|-------------|
| `id` | yes | string | Entity ID or path |

**Reducer behavior:** Sets `_removed: true` on entity and all nested children. Removed entities are excluded from rendering and child counts.

---

## Block Primitives (7–9)

Blocks define the page structure.

### 7. `block.set`

Create or update a block in the page tree.

```json
{
  "type": "block.set",
  "payload": {
    "id": "block_list",
    "type": "entity_view",
    "parent": "block_root",
    "position": 1,
    "props": {
      "source": "grocery_list"
    }
  }
}
```

| Field | Required | Type | Description |
|-------|----------|------|-------------|
| `id` | yes | string | Block ID |
| `type` | yes (on create) | string | Block type (see below) |
| `parent` | no | string | Parent block ID. Default: `"block_root"`. |
| `position` | no | number | Fractional position among siblings |
| `props` | no | object | Type-specific properties |

**Block types (v3):**

| Type | Props | Renders as |
|------|-------|-----------|
| `heading` | `level` (1–3), `content` | `<h1>`, `<h2>`, `<h3>` |
| `text` | `content` | `<p>` |
| `metric` | `label`, `value`, `trend?` | Key-value display |
| `entity_view` | `source` (entity path), `channel?` | Rendered entity using its schema template |
| `divider` | — | `<hr>` |
| `image` | `src`, `alt?`, `caption?` | `<img>` |
| `callout` | `content`, `icon?` | Highlighted block |
| `column_list` | — | Flex container for columns |
| `column` | `width?` | Flex child |

### 8. `block.remove`

Remove a block from the page tree.

```json
{
  "type": "block.remove",
  "payload": {
    "id": "block_list"
  }
}
```

### 9. `block.reorder`

Reorder children within a parent block.

```json
{
  "type": "block.reorder",
  "payload": {
    "parent": "block_root",
    "children": ["block_title", "block_list", "block_footer"]
  }
}
```

---

## Style Primitives (10–11)

### 10. `style.set`

Set global style tokens.

```json
{
  "type": "style.set",
  "payload": {
    "primary_color": "#2d3748",
    "font_family": "Inter",
    "density": "comfortable"
  }
}
```

**Known tokens:**

| Token | Values | Default |
|-------|--------|---------|
| `primary_color` | hex color | `"#2d3748"` |
| `bg_color` | hex color | `"#fafaf9"` |
| `text_color` | hex color | `"#1a1a1a"` |
| `font_family` | font name | `"Inter"` |
| `heading_font` | font name | `"Cormorant Garamond"` |
| `density` | `"compact"`, `"comfortable"`, `"spacious"` | `"comfortable"` |

### 11. `style.set_entity`

Set per-entity visual overrides.

```json
{
  "type": "style.set_entity",
  "payload": {
    "id": "grocery_list/items/item_milk",
    "styles": {
      "highlight": true,
      "bg_color": "#fef3c7"
    }
  }
}
```

---

## Meta Primitives (12–14)

### 12. `meta.update`

Update aide-level properties.

```json
{
  "type": "meta.update",
  "payload": {
    "title": "Poker League — Spring 2026",
    "identity": "Poker league. 8 players, biweekly Thursday."
  }
}
```

| Property | Type | Description |
|----------|------|-------------|
| `title` | string | Aide display name (used in `<title>` tag) |
| `identity` | string | What this aide is (used in blueprint) |
| `visibility` | string | `"public"`, `"unlisted"`, `"private"` |
| `archived` | bool | Whether the aide is archived |

### 13. `meta.annotate`

Append a note to the aide's annotation log.

```json
{
  "type": "meta.annotate",
  "payload": {
    "note": "Host rotation advanced. Dave hosting Feb 27.",
    "pinned": false
  }
}
```

### 14. `meta.constrain`

Declare an aide-level rule.

```json
{
  "type": "meta.constrain",
  "payload": {
    "id": "constraint_max_players",
    "rule": "max_children",
    "path": "poker_league/players",
    "value": 10,
    "message": "Maximum 10 players"
  }
}
```

| Rule | Check | Example |
|------|-------|---------|
| `max_children` | Path can't have more than N children | Max 10 players |
| `min_children` | Path must have at least N children | Min 2 guests per table |
| `unique_field` | No duplicate values for field in children | No duplicate names |
| `required_fields` | Fields must be non-null | Every player must have a name |

---

## Reserved (15–20)

Primitives 15–20 are reserved for future use. Candidates:

- `grid.create` — batch-create grid cells using tensor shape
- `grid.query` — query a grid cell by label
- `trigger.create` — declare a condition that fires events
- `computed.set` — declare a derived value
- `relationship.set` — typed links between entities
- `relationship.constrain` — relationship rules

---

## Validation Rules

The validation layer checks every primitive before it reaches the reducer.

### Universal checks (all primitives)
- `type` is a known primitive type
- `payload` is a non-null object
- All entity IDs match `^[a-z][a-z0-9_]{0,63}$`
- All schema IDs match `^[A-Z][a-zA-Z0-9]{0,63}$`

### Schema checks
- `schema.create`: TypeScript interface parses successfully, ID doesn't exist
- `schema.update`: schema exists, new interface parses, existing entities still valid
- `schema.remove`: no entities reference this schema

### Entity checks
- `entity.create`: schema exists, ID doesn't exist, fields match interface
- `entity.update`: entity exists (not removed), fields match interface
- `entity.remove`: entity exists

### Block checks
- `block.set`: parent exists (or is `block_root`), type is known
- `block.remove`: block exists, not `block_root`
- `block.reorder`: parent exists, all child IDs are current children

---

## Escalation Signal

When L2 can't compile a user message into valid primitives, it returns an escalation:

```json
{
  "type": "escalation",
  "reason": "no_schema",
  "user_message": "we need milk, eggs, and sourdough",
  "context": "No schemas exist. This is a new aide.",
  "attempted": null
}
```

| Reason | When |
|--------|------|
| `no_schema` | First message, no schemas exist |
| `unknown_entity` | Referenced entity doesn't exist |
| `schema_evolution` | User wants to track something not in current schema |
| `structural_change` | Request to reorganize the page layout |
| `ambiguous` | Can't determine intent with confidence |
| `image_input` | Image requires vision-capable model |

The orchestrator forwards escalations to L3, which synthesizes schemas and returns valid primitives.
